<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="it-IT" xml:lang="it-IT">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Leonardo Carminati" />
  <meta name="author" content="Maurizio Tomasi" />
  <title>Lezione 8: Equazioni differenziali</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Lezione 8: Equazioni differenziali</h1>
<blockquote class="metadata">
<p class="author">
      Leonardo CarminatiMaurizio Tomasi
  </p>
<p class="date before-toc"><time datetime="A.A. 2024‚àí2025">A.A. 2024‚àí2025</time></p>
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">‚äï</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#introduzione-a-stdarray" id="toc-introduzione-a-stdarray">Introduzione a <code>std::array</code></a></li>
  <li><a href="#esercizio-8.0" id="toc-esercizio-8.0">Esercizio 8.0 - Algebra vettoriale</a></li>
  <li><a href="#esercizio-8.1" id="toc-esercizio-8.1">Esercizio 8.1 - Risoluzione tramite metodo di Eulero</a>
  <ul>
  <li><a href="#il-metodo-di-eulero" id="toc-il-metodo-di-eulero">Il metodo di Eulero</a></li>
  <li><a href="#struttura-del-programma" id="toc-struttura-del-programma">Struttura del programma</a></li>
  <li><a href="#risultati-attesi" id="toc-risultati-attesi">Risultati attesi</a></li>
  </ul></li>
  <li><a href="#esercizio-8.2" id="toc-esercizio-8.2">Esercizio 8.2 - Risoluzione tramite Runge-Kutta (da consegnare)</a>
  <ul>
  <li><a href="#il-metodo-di-runge-kutta" id="toc-il-metodo-di-runge-kutta">Il metodo di Runge-Kutta</a></li>
  <li><a href="#cosa-ci-aspettiamo" id="toc-cosa-ci-aspettiamo">Cosa ci aspettiamo?</a></li>
  </ul></li>
  <li><a href="#esercizio-8.3" id="toc-esercizio-8.3">Esercizio 8.3 - Moto del pendolo (da consegnare)</a>
  <ul>
  <li><a href="#il-moto-del-pendolo" id="toc-il-moto-del-pendolo">Il moto del pendolo</a></li>
  <li><a href="#calcolo-del-periodo" id="toc-calcolo-del-periodo">Calcolo del periodo</a></li>
  <li><a href="#risultati-attesi-1" id="toc-risultati-attesi-1">Risultati attesi</a></li>
  </ul></li>
  <li><a href="#esercizio-8.4" id="toc-esercizio-8.4">Esercizio 8.4 - Oscillazione forzate e risonanza (da consegnare)</a>
  <ul>
  <li><a href="#oscillatore-armonico-con-forzante" id="toc-oscillatore-armonico-con-forzante">Oscillatore armonico con forzante</a></li>
  <li><a href="#risultati-attesi-2" id="toc-risultati-attesi-2">Risultati attesi</a></li>
  </ul></li>
  <li><a href="#esercizio-8.5" id="toc-esercizio-8.5">Esercizio 8.5 - Moto in campo gravitazionale</a>
  <ul>
  <li><a href="#moto-in-campo-gravitazionale" id="toc-moto-in-campo-gravitazionale">Moto in campo gravitazionale</a></li>
  <li><a href="#risultati-attesi-3" id="toc-risultati-attesi-3">Risultati attesi</a></li>
  </ul></li>
  <li><a href="#visualizzare-levoluzione-temporale" id="toc-visualizzare-levoluzione-temporale">Visualizzare l‚Äôevoluzione temporale</a></li>
  <li><a href="#esercizio-8.6" id="toc-esercizio-8.6">Esercizio 8.6 - Moto di una particella carica in un campo elettrico e magnetico uniforme</a>
  <ul>
  <li><a href="#moto-in-campo-elettrico-e-magnetico-uniformi" id="toc-moto-in-campo-elettrico-e-magnetico-uniformi">Moto in campo elettrico e magnetico uniformi</a></li>
  <li><a href="#risultati-attesi-4" id="toc-risultati-attesi-4">Risultati attesi</a></li>
  </ul></li>
  <li><a href="#errori-comuni" id="toc-errori-comuni">Errori comuni</a></li>
  </ul>
</nav>

<main>
<p>[La pagina con la spiegazione originale degli esercizi si trova qui: <a href="https://labtnds.docs.cern.ch/Lezione8/Lezione8/" class="uri">https://labtnds.docs.cern.ch/Lezione8/Lezione8/</a>.]</p>
<p>In questa lezione introdurremo alcuni metodi per la risoluzione di equazioni differenziali ordinarie. Implementeremo la risoluzione numerica di queste equazioni con i metodi di <em>Eulero</em> e di <em>Runge-Kutta</em>.</p>
<p>Per risolvere l‚Äôesercizio vedremo come √® possibile definire le principali operazioni algebriche per classi della STL come <code>std::vector</code> o il nuovo <code>std::array</code>. Questo ci permetter√† di realizzare i metodi di integrazione di equazioni differenziali usando una notazione vettoriale, molto simile al formalismo matematico.</p>
<h1 id="introduzione-a-stdarray">Introduzione a <code>std::array</code></h1>
<p>La STL fornisce varie implementazioni del concetto di ‚Äúarray‚Äù. Finora abbiamo sempre usato il tipo <code>std::vector</code>, che √® una versione pi√π potente degli array del C. Le due variabili <code>array</code> e <code>vec</code> nell‚Äôesempio contengono gli stessi elementi:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> array<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">};</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> stl_vec<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">};</span></span></code></pre></div>
<p>ma la variabile <code>stl_vec</code> ha pi√π funzionalit√†:</p>
<ul>
<li><p>√à sempre possibile sapere quanti elementi contenga con il metodo <code>ssize(stl_vec)</code> (o nel vecchio C++ <code>stl_vec.size()</code>, che <a href="tomasi-lezione-03.html#ssize-cpp">come abbiamo pi√π volte ripetuto</a> √® per√≤ <strong>sconsigliato</strong>);</p></li>
<li><p>Si possono aggiungere elementi in coda con <code>stl_vec.push_back()</code> e <a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back"><code>stl_vec.emplace_back()</code></a>;</p></li>
<li><p>Si possono rimuovere elementi con <a href="https://cplusplus.com/reference/vector/vector/erase/"><code>stl_vec.erase()</code></a>.</p></li>
<li><p>Se si usa la scrittura <code>stl_vec.at(4)</code> anzich√© <code>stl_vec[4]</code>, l‚Äôaccesso a un elemento non esistente dell‚Äôarray causa un messaggio di errore esplicito.</p></li>
</ul>
<p>Oltre a <code>std::vector</code>, la STL offre la possibilit√† di usare <a href="https://en.cppreference.com/w/cpp/container/array"><code>std::array</code></a>, che si comporta esattamente come <code>std::vector</code> a parte queste differenze:</p>
<ul>
<li><p>√à allocato sullo <em>stack</em> anzich√© sullo <em>heap</em>, quindi √® molto veloce da creare;</p></li>
<li><p>Proibisce di aggiungere e togliere elementi: il numero di elementi va definito in fase di dichiarazione e non pu√≤ essere modificato;</p></li>
<li><p>Va usato quando il numero di elementi nell‚Äôarray √® piccolo (<strong>qualche decina al massimo</strong>), altrimenti si rischia di riempire tutto lo <em>stack</em>;</p></li>
<li><p>Il compilatore √® sempre in grado di verificare che le dimensioni di un array siano consistenti. Ad esempio, se si somma un array <code>a</code> di due elementi ad un array <code>b</code> di quattro elementi, il compilatore produce un errore di compilazione. Questo non sarebbe vero se <code>a</code> e <code>b</code> fossero di tipo <code>std::vector</code>!</p></li>
</ul>
<p>Il testo originale degli esercizi di Carminati assume che negli esercizi di oggi si usi <code>std::vector</code>, ma il testo qui sotto vi mostrer√† invece come usare <code>std::array</code>, perch√© rende impossibile alcuni errori che gli studenti tendono a fare.</p>
<p>Questo √® il modo in cui si usa:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Notare che bisogna indicare il numero di elementi</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">// *dentro* le parentesi angolari &lt;&gt; del template!</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;</span> stl_arr<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">};</span></span></code></pre></div>
<p>La scrittura <code>array&lt;double, 3&gt;</code> pu√≤ sembrare strana: finora abbiamo sempre visto nelle parentesi angolari <code>&lt;&gt;</code> dei template tipi come <code>double</code> oppure <code>int</code>, ma il C++ permette anche di specificare <em>valori</em> come parametri dei template.</p>
<p>√à poi possibile implementare codice come se si stesse usando un oggetto di tipo <code>std::vector</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> ssize<span class="op">(</span>stl_arr<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ok anche `stl_arr[i]`, ma non controlla la</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// correttezza di `i`</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Valore #</span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> stl_arr<span class="op">.</span>at<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>ma √® vietato chiamare metodi come <code>stl_arr.push_back(5.0)</code>, perch√© la dimensione dell‚Äôarray non cambia mai!</p>
<p>Se si vogliono definire funzioni che operano su un array, nel template bisogna non solo indicare <code>&lt;typename T&gt;</code> come nel caso di <code>std::vector</code>, perch√© qui anche la <em>dimensione</em> dell‚Äôarray √® un parametro (che purtroppo va indicata come <code>size_t</code> anzich√© <code>int</code> üôÅ):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Using `int` instead of `size_t` doesn‚Äôt work‚Ä¶</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> n<span class="op">&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>array<span class="op">&lt;</span>T<span class="op">,</span> n<span class="op">&gt;</span> <span class="op">&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ‚Ä¶</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notate che <code>T</code> √® dichiarata come <code>typename</code>, perch√© questo parametro rappresenta un <em>tipo</em> come <code>double</code> oppure <code>int</code>, mentre <code>n</code> √® un numero (<code>size_t</code> √® un intero senza segno), perch√© questo non deve essere un tipo bens√¨ un <em>valore</em> come <code>2</code>, <code>5</code>, <code>14</code>‚Ä¶</p>
<h1 id="esercizio-8.0">Esercizio 8.0 - Algebra vettoriale</h1>
<p>Come prima cosa, proviamo a dotare il tipo <code>std::array</code> della STL di tutte le funzionalit√† algebriche che ci possono essere utili, definendo opportunamente gli operatori <code>+</code>, <code>*</code>, <code>/</code>, <code>+=</code>. Dal momento che non possiamo modificare gli header files e i files di implementazione della classe <code>std::array</code>, implementiamo questi operatori come funzioni libere in un header file apposito da includere quando necessario. Potete trovarne un esempio <a href="codici/array_operations.h">qui</a>.</p>
<p>Notate la presenza della funzione <code>test_array_operations()</code>, che verifica la correttezza delle operazioni su <code>std::array</code>. Usando solo numeri interi per le componenti dei vettori, non c‚Äô√® bisogno di invocare la nostra solita funzione <code>are_close()</code> perch√© in questo caso la variabile <code>double</code> opera senza arrotondamenti.</p>
<p>Ovviamente, per eseguire i test basta invocarli all‚Äôinizio di <code>main()</code>, come al solito:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;array_operations.h&quot;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  test_array_operations<span class="op">();</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Verificate che venga stampato il messaggio che certifica il successo dei test!</p>
<h1 id="esercizio-8.1">Esercizio 8.1 - Risoluzione tramite metodo di Eulero</h1>
<p>Nel primo esercizio implementeremo un codice per la risoluzione numerica dell‚Äôequazione differenziale che descrive il moto di un oscillatore armonico tramite il metodo di Eulero. Gli obiettivi principali di questo esercizio sono due:</p>
<ol type="1">
<li><p>Studiare l‚Äôandamento della posizione in funzione del tempo <code>t</code> (per <code>t</code> che va da 0 a 70 secondi) per un fissato passo di integrazione <code>h</code> (si potrebbe costruire un grafico, per esempio) e confrontare l‚Äôerrore commesso con la soluzione esatta.</p></li>
<li><p>Studiare l‚Äôandamento dell‚Äôerrore che si commette utilizzando il metodo di Eulero quando confrontiamo la soluzione approssimata con la soluzione esatta nell‚Äôistante t‚ÄØ=‚ÄØ70‚ÄØs in funzione del passo di integrazione <code>h</code> in un intervallo compreso tra 0.1 e 0.001.</p></li>
</ol>
<p>Per testare il metodo, risolviamo l‚Äôequazione differenziale:</p>
<p><span class="math display">
\frac{\mathrm{d}}{\mathrm{d}t} \begin{pmatrix}x\\v\end{pmatrix} =
\begin{pmatrix}v\\-\omega_0^2 x\end{pmatrix},\quad x(0) = 0, \quad v(0) = 1\,\text{m/s}, \quad \omega_0 = 1\,\text{s}^{-1},
</span></p>
<p>mettendo in grafico il valore della <span class="math inline">x</span> in funzione del tempo <span class="math inline">t</span> ed eventualmente anche il suo errore rispetto alla soluzione esatta del problema, che √® <span class="math inline">x(t) = \sin (t)</span>. Si consiglia di svolgere l‚Äôintegrazione per un certo numero di periodi, in modo da vedere se l‚Äôampiezza di oscillazione rimane costante. Integrare fino a <span class="math inline">t = 70\,\text{s}</span> permette di vedere circa 10 periodi.</p>
<h2 id="il-metodo-di-eulero">Il metodo di Eulero</h2>
<p>Consideriamo la seconda legge della dinamica di Newton:</p>
<p><span class="math display">
a = \frac{\mathrm{d}^2 x}{\mathrm{d}t^2} = \frac{F}m.
</span></p>
<p>Essa √® un‚Äôequazione differenziale del secondo ordine che pu√≤ essere ridotta ad un‚Äôequazione differenziale del prim‚Äôordine introducendo la variabile velocit√†:</p>
<p><span class="math display">
\begin{aligned}
\frac{\mathrm{d} x}{\mathrm{d}t} &amp;= v,\\
\frac{\mathrm{d} v}{\mathrm{d}t} &amp;= \frac{F}m.
\end{aligned}
</span></p>
<p>Il metodo di Eulero consiste nel calcolare lo stato della soluzione al tempo <span class="math inline">t + h</span> dato quello ad un tempo <span class="math inline">t</span> tramite le espressioni:</p>
<p><span class="math display">
\begin{aligned}
x(t + h) &amp;\approx x(t) + h \cdot \dot{x}(t) = x(t) + h \cdot v,\\
v(t + h) &amp;\approx v(t) + h \cdot \dot{v}(t) = x(t) + h \cdot \frac{F}m.
\end{aligned}
</span></p>
<h2 id="struttura-del-programma">Struttura del programma</h2>
<p>Struttureremo la soluzione del problema in modo simile a quanto fatto nelle precedenti lezioni su ricerca degli zeri e integrazione numerica:</p>
<ul>
<li>Definiamo una classe astratta <code>FunzioneVettorialeBase</code> con un unico metodo <code>Eval</code>, puramente virtuale, che dato un <code>array</code> ed un <code>double</code>, rappresentante il tempo, restituisce il valore della derivata prima nel punto e nell‚Äôistante considerati.</li>
<li>Da questa classe astratta, deriviamo una classe concreta <code>OscillatoreArmonico</code>, nella quale implementeremo il metodo <code>Eval</code> concreto relativo all‚Äôoscillatore armonico.</li>
<li>Definiamo una classe astratta <code>EquazioneDifferenzialeBase</code> che contenga il metodo virtuale puro <code>Passo</code>, puramente virtuale, che dati il tempo <span class="math inline">t</span>, un vettore <span class="math inline">\vec x</span>, il passo di integrazione <span class="math inline">h</span> e un puntatore ad una <code>FunzioneVettorialeBase</code>, restituisca la una stima del valore della posizione <span class="math inline">\vec x</span> al tempo <span class="math inline">t + h</span>. Avere il tempo <span class="math inline">t</span> come argomento esplicito non serve per questo esercizio in particolare, ma permetter√† in futuro (come ad esempio nell‚Äôesercizio <a href="carminati-esercizi-08.html#esercizio-8.4">8.4</a>) di avere forzanti esterne o parametri dipendenti dal tempo.</li>
<li>Da questa classe astratta, deriviamo una classe concreta che implementi il metodo <code>Passo</code> relativo al metodo di Eulero.</li>
</ul>
<p>Per comodit√† possiamo mettere tutte queste classi nello stesso header file che potrebbe avere l‚Äôaspetto seguente:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;array_operations.h&quot;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// classe astratta, restituisce la derivata valutata nel punto x</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">// di una funzione a `n` dimensioni, dove `n` √® un parametro del</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">// template</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> n<span class="op">&gt;</span> <span class="kw">class</span> FunzioneVettorialeBase <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">virtual</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> n<span class="op">&gt;</span> Eval<span class="op">(</span><span class="dt">double</span> t<span class="op">,</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">const</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> n<span class="op">&gt;</span> <span class="op">&amp;</span>x<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">// caso fisico concreto, oscillatore armonico a 1 dimensione,</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co">// che corrisponde ad una dimensione 2 nello spazio delle fasi</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co">// (notare `&lt;2&gt;` alla fine di `FunzioneVettorialeBase`: questa</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">// classe *non* √® template, perch√© sia il tipo T che il numero n</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co">// sono definiti ed univoci: `double` e `2`).</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> OscillatoreArmonico <span class="op">:</span> <span class="kw">public</span> FunzioneVettorialeBase<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  OscillatoreArmonico<span class="op">(</span><span class="dt">double</span> omega0<span class="op">)</span> <span class="op">:</span> <span class="va">m_omega0</span><span class="op">{</span>omega0<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>  Eval<span class="op">(</span><span class="dt">double</span> t<span class="op">,</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>       <span class="at">const</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> <span class="op">&amp;</span>x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Implementare il metodo</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_omega0</span><span class="op">;</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="co">// classe astratta per un integratore di equazioni differenziali</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co">// (Eulero, Runge Kutta, etc.) a N dimensioni</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> n<span class="op">&gt;</span> <span class="kw">class</span> EquazioneDifferenzialeBase <span class="op">{</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">virtual</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> n<span class="op">&gt;</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>  Passo<span class="op">(</span><span class="dt">double</span> t<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> n<span class="op">&gt;</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> FunzioneVettorialeBase<span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="op">&amp;</span>f<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="co">// integratore concreto, metodo di Eulero a N dimensioni</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">size_t</span> n<span class="op">&gt;</span> <span class="kw">class</span> Eulero <span class="op">:</span> <span class="kw">public</span> EquazioneDifferenzialeBase<span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> n<span class="op">&gt;</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>  Passo<span class="op">(</span><span class="dt">double</span> t<span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> n<span class="op">&gt;</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        <span class="at">const</span> FunzioneVettorialeBase<span class="op">&lt;</span>n<span class="op">&gt;</span> <span class="op">&amp;</span>f<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Implementare il metodo: basta una riga di codice per Eulero!</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a><span class="co">// Test del metodo di Eulero</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a><span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="kw">inline</span> <span class="dt">double</span> are_close<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">double</span> eps <span class="op">=</span> <span class="fl">1e-7</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> abs<span class="op">(</span>a <span class="op">-</span> b<span class="op">)</span> <span class="op">&lt;</span> eps <span class="op">*</span> fabs<span class="op">(</span>a<span class="op">);</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> <span class="dt">void</span> test_euler<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Verifica la correttezza del metodo di Eulero integrando</span></span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>  <span class="co">// l&#39;oscillatore armonico con œâ‚ÇÄ=1 rad/s e verificando che</span></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">// al tempo t=0.9‚ÄØs posizione e velocit√† coincidano con</span></span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>  <span class="co">// la soluzione del codice Julia all&#39;indirizzo</span></span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>  <span class="co">// https://ziotom78.github.io/tnds-notebooks/lezione08/#esercizio_81_metodo_di_eulero</span></span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>  Eulero<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;</span> my_euler<span class="op">{};</span></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>  OscillatoreArmonico osc<span class="op">{</span><span class="fl">1.</span><span class="op">};</span></span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> tmax<span class="op">{</span><span class="fl">0.91</span><span class="op">};</span> <span class="co">// √à pi√π sicuro usare qualcosa di pi√π di 0.9</span></span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> h<span class="op">{</span><span class="fl">0.1</span><span class="op">};</span></span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> x<span class="op">{</span><span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">};</span></span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> t<span class="op">{};</span></span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `lround` √® come `round`, ma arrotonda sempre verso il basso</span></span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> num_of_steps<span class="op">{(</span><span class="dt">int</span><span class="op">)</span> lround<span class="op">(</span>tmax <span class="op">/</span> h<span class="op">)};</span></span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>  <span class="co">// evoluzione del sistema fino a 0.9‚ÄØs</span></span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> step<span class="op">{};</span> step <span class="op">&lt;</span> num_of_steps<span class="op">;</span> step<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> my_euler<span class="op">.</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> osc<span class="op">);</span></span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t <span class="op">+</span> h<span class="op">;</span></span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Questi sono i numeri prodotti dal codice Julia. Verifichiamo fino</span></span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>  <span class="co">// alla sesta cifra, perch√© i numeri stampati dal programma Julia</span></span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>  <span class="co">// usavano questa convenzione</span></span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>x<span class="op">[</span><span class="dv">0</span><span class="op">],</span> <span class="fl">0.817256</span><span class="op">,</span> <span class="fl">1e-6</span><span class="op">));</span></span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>x<span class="op">[</span><span class="dv">1</span><span class="op">],</span> <span class="fl">0.652516</span><span class="op">,</span> <span class="fl">1e-6</span><span class="op">));</span></span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Una volta implementate le classi (l‚Äôimplementazione di Eulero √® semplicissima se si usano le operazioni di algebra vettoriale), un possibile programma per risolvere l‚Äôesercizio √® il seguente:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;array_operations.h&quot;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;equazioni_differenziali.h&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;gplot++.h&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  test_array_operations<span class="op">();</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  test_euler<span class="op">();</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>argc <span class="op">!=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>cerr<span class="op">,</span> <span class="st">&quot;Uso: </span><span class="sc">{}</span><span class="st"> PASSO&quot;</span><span class="op">,</span> argv<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  Eulero<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;</span> my_euler<span class="op">{};</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  OscillatoreArmonico osc<span class="op">{</span><span class="fl">1.</span><span class="op">};</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> tmax<span class="op">{</span><span class="fl">70.</span><span class="op">};</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> h<span class="op">{</span>stof<span class="op">(</span>argv<span class="op">[</span><span class="dv">1</span><span class="op">])};</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> t<span class="op">{};</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> x<span class="op">{</span><span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">};</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">int</span> num_of_steps<span class="op">{(</span><span class="dt">int</span><span class="op">)</span>lround<span class="op">(</span>tmax <span class="op">/</span> h<span class="op">)};</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">// evoluzione del sistema fino a 70 s</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>  Gnuplot plt<span class="op">{};</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ho bisogno di costruire due vettori per poter poi</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">// fare il plot. Qui uso &quot;vector&quot; anzich√© &quot;array&quot;,</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// perch√© le due liste potrebbero essere molto grandi</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">// e si rischierebbe quindi di riempire lo stack.</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Notare che uso `()` anzich√© `{}` per passare i</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// parametri del costruttore, perch√© voglio</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">// specificare il *numero di elementi* del vettore!</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> <span class="dt">list_of_t</span><span class="op">(</span>num_of_steps<span class="op">);</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> list_of_x<span class="op">(</span>num_of_steps<span class="op">);</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> step <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> step <span class="op">&lt;</span> num_of_steps<span class="op">;</span> step<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Salva le coordinate del punto (t, x) per</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">// fare poi il grafico</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">list_of_t</span><span class="op">.</span>at<span class="op">(</span>step<span class="op">)</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>    list_of_x<span class="op">.</span>at<span class="op">(</span>step<span class="op">)</span> <span class="op">=</span> x<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Stampa i risultati in forma di tabella</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    <span class="co">// (da fare sempre! aiuta nel trovare errori)</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{:.1f}</span><span class="st"> </span><span class="sc">{:.6f}</span><span class="st"> </span><span class="sc">{:.6f}</span><span class="st">&quot;</span><span class="op">,</span> t<span class="op">,</span> x<span class="op">[</span><span class="dv">0</span><span class="op">],</span> x<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ‚ÄúAvanza‚Äù di un passo `h` la soluzione in `x`</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> my_euler<span class="op">.</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> osc<span class="op">);</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t <span class="op">+</span> h<span class="op">;</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ora si pu√≤ produrre il grafico</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>string filename<span class="op">{</span><span class="st">&quot;euler.png&quot;</span><span class="op">};</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>redirect_to_png<span class="op">(</span>filename<span class="op">);</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>plot<span class="op">(</span><span class="dt">list_of_t</span><span class="op">,</span> list_of_x<span class="op">);</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Tempo [s]&quot;</span><span class="op">);</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;Oscillazione [m]&quot;</span><span class="op">);</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>  <span class="co">// √à sempre bene dare all&#39;utente un feedback di ci√≤ che</span></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>  <span class="co">// si √® fatto: in questo modo l&#39;utente sapr√† quale file aprire!</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Finito, il risultato √® nel grafico &#39;</span><span class="sc">{}</span><span class="st">&#39;&quot;</span><span class="op">,</span> filename<span class="op">);</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Il codice sopra usa la libreria <a href="https://github.com/ziotom78/gplotpp">gplot++</a> per salvare il grafico della soluzione in un file PNG. Se invece volete usare ROOT, queste sono le righe da aggiungere alla seconda parte del <code>main</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>TApplication myApp<span class="op">{</span><span class="st">&quot;myApp&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>TGraph <span class="op">*</span>myGraph<span class="op">{</span><span class="kw">new</span> TGraph<span class="op">()};</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> step<span class="op">{};</span> step <span class="op">&lt;</span> num_of_steps<span class="op">;</span> step<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    myGraph<span class="op">-&gt;</span>SetPoint<span class="op">(</span>step<span class="op">,</span> t<span class="op">,</span> x<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> myEuler<span class="op">.</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> osc<span class="op">);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span>t<span class="op">,</span> x<span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>TCanvas <span class="op">*</span>c<span class="op">{</span><span class="kw">new</span> TCanvas<span class="op">()};</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>c<span class="op">-&gt;</span>cd<span class="op">();</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>string title<span class="op">{</span>format<span class="op">(</span><span class="st">&quot;Oscillatore armonico (Eulero, h = </span><span class="sc">{}</span><span class="st">)&quot;</span><span class="op">,</span> h<span class="op">)};</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>myGraph<span class="op">-&gt;</span>SetTitle<span class="op">(</span>title<span class="op">.</span>c_str<span class="op">());</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>myGraph<span class="op">-&gt;</span>GetXaxis<span class="op">()-&gt;</span>SetTitle<span class="op">(</span><span class="st">&quot;Tempo [s]1&quot;</span><span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>myGraph<span class="op">-&gt;</span>GetYaxis<span class="op">()-&gt;</span>SetTitle<span class="op">(</span><span class="st">&quot;Posizione x [m]&quot;</span><span class="op">);</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>myGraph<span class="op">-&gt;</span>Draw<span class="op">(</span><span class="st">&quot;AL&quot;</span><span class="op">);</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>myApp<span class="op">.</span>Run<span class="op">();</span></span></code></pre></div>
<p>Si riveda il solito esempio (<a href="./codici/test_tgraph.cpp">qui</a>) per l‚Äôuso dei <code>TGraph</code> di ROOT.</p>
<h2 id="risultati-attesi">Risultati attesi</h2>
<p>Il metodo di Eulero non √® molto accurato; in effetti, con un passo di integrazione modesto si vede come esso possa risultare instabile, mostrando oscillazioni la cui ampiezza varia con il tempo. La figura sotto mostra l‚Äôandamento di <span class="math inline">x(t)</span> con un passo di integrazione di 0.1¬†s:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/Eulero-01.png" /></p>
<p>Per avere qualcosa di anche solo visivamente accettabile, bisogna andare a passi di almeno 0.0002¬†s:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/Eulero-00001.png" /></p>
<p>La figura seguente riporta l‚Äôerrore accumulato dopo 70 s di integrazione per diversi valori del passo:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/errore_eulero.png" /></p>
<p>Si noti come la pendenza della curva sia 1 in una scala log-log, mostrando come l‚Äôerrore ottenuto sia proporzionale al passo <span class="math inline">h</span>.</p>
<h1 id="esercizio-8.2">Esercizio 8.2 - Risoluzione tramite Runge-Kutta (da consegnare)</h1>
<p>Ripetere l‚Äô<a href="carminati-esercizi-08.html#esercizio-8.1">esercizio 8.1</a> con il metodo di risoluzione di equazioni differenziali di Runge-Kutta (del quarto ordine) e confrontare quindi in condizioni analoghe (<span class="math inline">t</span> massimo e <span class="math inline">h</span>) la stabilit√† dei due metodi.</p>
<p>Per svolgere l‚Äôesercizio, baster√† realizzare una nuova classe concreta a partire da <code>EquazioneDifferenzialeBase</code>. Implementate anche un metodo <code>test_runge_kutta()</code> sulla falsariga di <code>test_euler()</code> per l‚Äô<a href="http://0.0.0.0:8000/carminati-esercizi-08.html#struttura-del-programma">esercizio 8.1</a>.</p>
<h2 id="il-metodo-di-runge-kutta">Il metodo di Runge-Kutta</h2>
<p>Il noto metodo di Runge-Kutta √® un metodo del quarto ordine ed utilizza la seguente determinazione dell‚Äôincremento:</p>
<p><span class="math display">
\begin{aligned}
k_1 &amp;= \dot{x}(t, x),\\
k_2 &amp;= \dot{x}\left(t + h / 2, x + k_1 \cdot \frac{h}2\right),\\
k_3 &amp;= \dot{x}\left(t + h / 2, x + k_2 \cdot \frac{h}2\right),\\
k_4 &amp;= \dot{x}\left(t + h, x + k_3 \cdot h\right),\\
x(t+h) &amp;= x(t) + (k_1 + 2k_2 + 2k_3 + k_4)\frac{h}6.
\end{aligned}
</span></p>
<h2 id="cosa-ci-aspettiamo">Cosa ci aspettiamo?</h2>
<p>Il metodo di Runge-Kutta del quarto ordine √® molto pi√π preciso del metodo di Eulero: infatti produce oscillazioni molto stabili anche con un passo di integrazione di 0.1¬†s:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/RungeKutta-01.png" /></p>
<p>La figura seguente riporta l‚Äôerrore accumulato dopo 70¬†s di integrazione per diversi valori del passo:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/errore_rk.png" /></p>
<p>Si noti come la pendenza della curva nella sua parte iniziale sia 4 in una scala log-log, mostrando come l‚Äôerrore ottenuto sia proporzionale a <span class="math inline">h^4</span>. Quando l‚Äôerrore di troncamento del metodo diventa minore degli errori di arrotondamento della macchina si vede che non c‚Äô√® pi√π alcun miglioramento nel ridurre il passo, anzi, il maggior numero di calcoli richiesto risulta in un peggioramento globale dell‚Äôerrore.</p>
<h1 id="esercizio-8.3">Esercizio 8.3 - Moto del pendolo (da consegnare)</h1>
<p>Incominciamo ora con una carrellata di interessanti applicazioni dei metodi che abbiamo appena studiato. In questo esercizio proveremo ad implementare la risoluzione dell‚Äôequazione del moto del pendolo: per prima cosa possiamo provare a fare un grafico dell‚Äôandamento dell‚Äôampiezza dell‚Äôoscillazione in funzione del tempo. La cosa pi√π interessante che possiamo studiare con questo codice √® l‚Äôandamento del periodo di oscillazione in funzione dell‚Äôampiezza di oscillazione: in questo modo possiamo verificare che per angoli grandi le oscillazioni non sono pi√π isocrone. La struttura logica dell‚Äôesercizio dovrebbe essere la seguente:</p>
<ol type="1">
<li><p>Portare il sistema in una condizione iniziale (Œ∏‚ÇÄ,‚ÄØ0);</p></li>
<li><p>Far evolvere il sistema usando il metodo di Eulero o di Runge-Kutta con passo di integrazione <span class="math inline">h</span> opportuno;</p></li>
<li><p>Calcolare il periodo di oscillazione del pendolo;</p></li>
<li><p>Riportare il sistema ad una condizione iniziale con ampiezza Œ∏‚ÇÄ variata e ripetere la sequenza di operazioni</p></li>
</ol>
<p>Si suggerisce di far variare Œ∏‚ÇÄ tra 0.1 e 3 radianti, in passi di 0.1 radianti.</p>
<h2 id="il-moto-del-pendolo">Il moto del pendolo</h2>
<p>L‚Äôequazione del pendolo √® data dalla relazione</p>
<p><span class="math display">
\frac{\mathrm{d}^2\theta}{\mathrm{d}t^2} = -\frac{g}{l}\sin\theta,
</span></p>
<p>dove <span class="math inline">g = 9.8\,\text{m/s}^2</span> √® l‚Äôaccellerazione di gravit√† sulla superficie terreste, mentre <span class="math inline">l</span> √® la lunghezza del pendolo.</p>
<p>L‚Äôequazione differenziale si pu√≤ approssimare con quella di un oscillatore armonico per piccole oscillazioni, <span class="math inline">\sin\theta\sim\theta</span>. In tal caso, le oscillazioni risultano isocrone, cio√® con periodo indipendente dall‚Äôampiezza delle oscillazioni. Questa per√≤ √® solo un‚Äôapprossimazione, e per grandi oscillazioni bisogna usare l‚Äôequazione esatta.</p>
<h2 id="calcolo-del-periodo">Calcolo del periodo</h2>
<p>In questo caso l‚Äôintegrazione numerica dell‚Äôequazione differenziale non si pu√≤ effettuare per un tempo predefinito, ma deve essere portata avanti fino a quando non si raggiunge una condizione compatibile con l‚Äôaver terminato l‚Äôoscillazione.</p>
<ul>
<li><p>Una possibile soluzione consiste nel portare avanti l‚Äôintegrazione fino a quando non si registra un cambiamento di segno della velocit√† angolare;</p></li>
<li><p>Siccome possiamo calcolare la velocit√† solo con granularit√† pari al passo di integrazione, possiamo migliorare la stima del periodo di oscillazione interpolando linearmente tra i punti <span class="math inline">(t,v(t))</span> e <span class="math inline">(t+h,v(t+h))</span> calcolando quando la retta ottenuta passa per lo zero; il tempo cos√¨ calcolato corrisponde al semiperiodo dell‚Äôoscillazione.</p></li>
</ul>
<p>Un frammento di codice che implementa questo algoritmo √® il seguente:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> A<span class="op">{</span><span class="fl">0.1</span> <span class="op">*</span> <span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">)};</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> v<span class="op">{};</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> t<span class="op">{};</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> x<span class="op">{-</span>A <span class="op">,</span> v<span class="op">}</span> <span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>x<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> x<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> myRK4<span class="op">.</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> osc<span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> t <span class="op">+</span> h<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> A<span class="op">,</span> x<span class="op">[</span><span class="dv">0</span><span class="op">],</span> t<span class="op">);</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> t <span class="op">-</span> v <span class="op">*</span> h <span class="op">/</span> <span class="op">(</span>x<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> v<span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Il periodo √® il *doppio* del tempo che abbiamo trovato!</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> period<span class="op">{</span><span class="dv">2</span> <span class="op">*</span> t<span class="op">};</span></span></code></pre></div>
<p><strong>Controllate la formula di interpolazione!</strong></p>
<h2 id="risultati-attesi-1">Risultati attesi</h2>
<p>La figura illustra il periodo al variare dell‚Äôampiezza per un pendolo con <span class="math inline">l = 1\,\text{m}</span>:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/periodo_pendolo.png" /></p>
<p>Si noti come per piccole oscillazioni il periodo sia effettivamente quello atteso dall‚Äôapprossimazione dell‚Äôoscillatore armonico:</p>
<p><span class="math display">
T = \frac{2\pi}{\sqrt{\frac{g}l}} \approx 2.007\,\text{s},
</span></p>
<p>ma aumenti significativamente per grandi ampiezze.</p>
<h1 id="esercizio-8.4">Esercizio 8.4 - Oscillazione forzate e risonanza (da consegnare)</h1>
<p>Implementare la risoluzione dell‚Äôequazione di un oscillatore armonico smorzato con forzante. Fare quindi un grafico della soluzione stazionaria in funzione della frequenza dell‚Äôoscillatore, ricostruendo la curva di risonanza. La struttura logica dell‚Äôesercizio dovrebbe essere la seguente:</p>
<ul>
<li><p>Costruiamo un oscillatore armonico forzato con smorzante con una pulsazione propria œâ‚ÇÄ=10‚ÄØrad/s e una costante Œ±=1/30‚ÄØs.</p></li>
<li><p>Impostiamo un valore della pulsazione della forzante œâ (si consiglia di esplorare un intervallo per œâ tra 9‚ÄØrad/s e 11‚ÄØrad/s in passi da 0.05‚ÄØrad/s).</p></li>
<li><p>Mettiamo il sistema nella sua condizione iniziale <span class="math inline">x=0</span> e <span class="math inline">v_x=0</span>.</p></li>
<li><p>Facciamo evolvere il sistema usando il metodo di Runge-Kutta con passo di integrazione h opportuno fino all‚Äôesaurirsi del transiente.</p></li>
<li><p>Calcoliamo l‚Äôampiezza dell‚Äôoscillazione.</p></li>
<li><p>Modifichiamo il valore della pulsazione della forzante œâ e riportiamo il sistema alle condizioni iniziali <span class="math inline">x=0</span> e <span class="math inline">v_x=0</span>, ripetendo poi la sequenza di operazioni</p></li>
</ul>
<h2 id="oscillatore-armonico-con-forzante">Oscillatore armonico con forzante</h2>
<p>L‚Äôequazione dell‚Äôoscillatore armonico smorzato con forzante √® data dalla relazione</p>
<p><span class="math display">
\frac{\mathrm{d}^2x}{\mathrm{d}t^2} = -\omega_0^2 x - \alpha \dot{x}(t) + a_0 \sin(\omega t).
</span></p>
<p>Nell‚Äôesercizio proposto, utilizzare i seguenti valori iniziali: <span class="math display">
\omega_0 = 10\,\text{rad/s}, \quad \alpha = \frac1{30\,\text{s}}, \quad a_0 = 1\,\text{m/s}^2.
</span></p>
<h2 id="risultati-attesi-2">Risultati attesi</h2>
<p>La figura seguente riporta l‚Äôandamento dell‚Äôampiezza in funzione del tempo nel caso in cui la frequenza propria del sistema (œâ‚ÇÄ) e quella della forzante (œâ) coincidano: œâ‚ÇÄ‚ÄØ=‚ÄØœâ‚ÄØ=‚ÄØ10‚ÄØrad/s.</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/forzato_10_short.png" /></p>
<p>√à bene ricordare che per determinare l‚Äôampiezza bisogna aspettare che il transiente delle oscillazioni si esaurisca. Questo avviene con una costante di tempo pari a 1/Œ± (ovvero, dopo un tempo 1/Œ± l‚Äôampiezza di oscillazione si riduce di un fattore 1/e).</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/forzato_10_long.png" /></p>
<p>Si consiglia quindi di integrare l‚Äôequazione differenziale per un tempo pari ad almeno dieci volte 1/Œ±, in modo da raggiungere una situazione in cui l‚Äôoscillazione √® stabile, e poi valutare l‚Äôampiezza. Anche in questo caso si pu√≤ assumere di aver raggiunto il massimo dell‚Äôoscillazione nel momento in cui si trova un punto in cui la velocit√† cambia di segno.</p>
<p>Una curva di risonanza √® illustrata in figura:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/risonanza.png" /></p>
<h1 id="esercizio-8.5">Esercizio 8.5 - Moto in campo gravitazionale</h1>
<p>Implementare la risoluzione dell‚Äôequazione del moto di un corpo in un campo gravitazionale.</p>
<ul>
<li><p>Verificare, nel caso del sistema Terra-Sole, che il periodo di rivoluzione della Terra intorno al Sole sia effettivamente di un anno e che l‚Äôorbita sia periodica. Calcolare quindi il rapporto tra perielio ed afelio.</p></li>
<li><p>Provare ad aggiungere una piccola perturbazione al potenziale gravitazionale (ad esempio un termine proporzionale ad <span class="math inline">1/r^3</span> nella forza) e verificare che le orbite non sono pi√π chiuse ma formano una rosetta.</p></li>
</ul>
<h2 id="moto-in-campo-gravitazionale">Moto in campo gravitazionale</h2>
<p>Nell‚Äôimplementare il moto di un corpo in un campo gravitazionale utilizzare le seguenti condizioni:</p>
<ul>
<li>costante gravitazionale <span class="math inline">G = 6.6742\times 10^{-11}\,\text{m}^3\,\text{kg}^{-1}\,\text{s}^{-2}</span>;</li>
<li>massa del Sole <span class="math inline">M_\odot = 1.988441030\times 10^{30}\,\text{kg}</span>;</li>
<li>distanza Terra-Sole al perielio <span class="math inline">D_p = 1.47098074\times 10^{11}\,\text{m}</span>;</li>
<li>velocit√† al perielio <span class="math inline">v_p = 3.0287\times 10^4\,\text{m/s}</span>.</li>
</ul>
<p>Ovviamente, essendo tutti voi studenti di fisica, non c‚Äô√® alcun bisogno di ricordarvi che nel vostro codice le unit√† di misura devono essere consistenti‚Ä¶ quindi non ve lo ricorder√≤! üòâ</p>
<h2 id="risultati-attesi-3">Risultati attesi</h2>
<p>Nel caso di potenziale gravitazionale standard dovremmo ottenere una traiettoria di questo tipo:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/orbita.png" /></p>
<p>Aggiungendo un termine di perturbazione Œ±/r¬≥ al potenziale gravitazionale, la traiettoria diventa la seguente:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/rosetta.png" /></p>
<h1 id="visualizzare-levoluzione-temporale">Visualizzare l‚Äôevoluzione temporale</h1>
<p>In questo caso potrebbe essere interessante visualizzare l‚Äôevoluzione temporale della traiettoria della terra in modo dinamico. Per fare questo possiamo semplicemente visualizzare il grafico della traiettoria ogni volta che viene aggiunto un nuovo punto, introducendo un‚Äôattesa nel ciclo <code>for</code> per regolare la velocit√† dell‚Äôanimazione: il C++ fornisce la funzione <code>std::this_thread::sleep_for()</code>, che richiede un tempo definito tramite le funzioni in <code>&lt;chrono&gt;</code>, quindi occorrono queste librerie:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;thread&gt;</span></span></code></pre></div>
<p>Per introdurre un ritardo prima di eseguire il ciclo seguente, bisogna quindi invocare <code>sleep_for</code> nel modo seguente:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>Gnuplot gpl<span class="op">{};</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> plot_range<span class="op">{</span><span class="fl">160e9</span><span class="op">};</span> <span class="co">// Maximum distance from the Sun</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> npoint<span class="op">{};</span> npoint <span class="op">&lt;</span> nstep <span class="op">;</span> npoint<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Add the point, plot the graph and show the new frame</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>add_point<span class="op">(</span>x<span class="op">[</span><span class="dv">0</span><span class="op">],</span> x<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>plot<span class="op">();</span>  <span class="co">// Make the plot in memory (hidden from the user)</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Be sure that the axes don&#39;t change during the animation</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_xrange<span class="op">(-</span>plot_range<span class="op">,</span> plot_range<span class="op">);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_yrange<span class="op">(-</span>plot_range<span class="op">,</span> plot_range<span class="op">);</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>show<span class="op">();</span>  <span class="co">// Show the plot in the Gnuplot window</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Wait for 1 ms</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>this_thread::sleep_for<span class="op">(</span><span class="bu">std::</span>chrono::milliseconds<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Step to the next point</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> integratore<span class="op">-&gt;</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> f<span class="op">);</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A partire dalla versione 0.9.0, <a href="https://github.com/ziotom78/gplotpp">gplot++</a> fornisce per√≤ il metodo <code>redirect_to_animated_gif</code>, che crea un file GIF animato contenente l‚Äôanimazione; in questo caso non serve includere <code>&lt;chrono&gt;</code> o <code>&lt;thread&gt;</code>. Il metodo richiede questi parametri:</p>
<ul>
<li>Nome del file GIF da creare;</li>
<li>Dimensioni del file, in forma di stringa (es., <code>"800,600"</code>);</li>
<li>Numero di millisecondi di attesa tra un fotogramma e il successivo.</li>
</ul>
<p>Con <a href="https://github.com/ziotom78/gplotpp">gplot++</a>, il codice diventerebbe questo:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Gnuplot gpl<span class="op">{};</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>redirect_to_animated_gif<span class="op">(</span><span class="st">&quot;es8.4.gif&quot;</span><span class="op">,</span> <span class="st">&quot;800,600&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> plot_range<span class="op">{</span><span class="fl">160e9</span><span class="op">};</span> <span class="co">// Maximum distance from the Sun</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> npoint<span class="op">{};</span> npoint <span class="op">&lt;</span> nstep <span class="op">;</span> npoint<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Add the point, plot the graph and show the new frame</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>add_point<span class="op">(</span>x<span class="op">[</span><span class="dv">0</span><span class="op">],</span> x<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>plot<span class="op">();</span>  <span class="co">// Make the plot in memory (hidden from the user)</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Be sure that the axes don&#39;t change during the animation</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_xrange<span class="op">(-</span>plot_range<span class="op">,</span> plot_range<span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_yrange<span class="op">(-</span>plot_range<span class="op">,</span> plot_range<span class="op">);</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>show<span class="op">();</span>  <span class="co">// Show the plot in the Gnuplot window</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Step to the next point</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> integratore<span class="op">-&gt;</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> f<span class="op">);</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>  t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Di seguito un esempio di file GIF creato con un termine aggiuntivo di forza espresso come <span class="math display">
F&#39;(\vec r) = -\alpha G \frac{M_\odot\,M_t\,D_p}{r^4} \vec r,
</span> dove <span class="math inline">\alpha = 0.3</span> √® un numero puro e <span class="math inline">D_p</span> √® la distanza Terra-Sole al perielio. Lo step usato per l‚Äôanimazione √® cinque giorni (ossia, <span class="math inline">h = 86\,400\,\text{s/day} \times 5\,\text{day}</span>):</p>
<p><img src="images/es8.5.gif" /></p>
<p>Se usate ROOT anzich√© <a href="https://github.com/ziotom78/gplotpp">gplot++</a>, dovete includere anche <code>TSystem.h</code> perch√© ROOT deve sincronizzare le operazioni di disegno tramite <code>gSystem-&gt;ProcessEvents()</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;TSystem.h&quot;</span></span></code></pre></div>
<p>e il codice diventerebbe il seguente:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// creazione TGraph e TCanvas</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>TGraph tRosetta<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>TCanvas CRosetta<span class="op">{</span><span class="st">&quot;CRosetta&quot;</span><span class="op">,</span> <span class="st">&quot;CRosetta&quot;</span><span class="op">,</span> <span class="dv">600</span><span class="op">,</span> <span class="dv">600</span><span class="op">};</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>tRosetta<span class="op">.</span>GetXaxis<span class="op">()-&gt;</span>SetTitle<span class="op">(</span><span class="st">&quot;x (m)&quot;</span><span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>tRosetta<span class="op">.</span>GetYaxis<span class="op">()-&gt;</span>SetTitle<span class="op">(</span><span class="st">&quot;y (m)&quot;</span><span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> npoint<span class="op">{};</span> npoint <span class="op">&lt;</span> nstep <span class="op">;</span> npoint<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// add the point, plot the graph and update the view</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  tRosetta<span class="op">.</span>SetPoint<span class="op">(</span>npoint<span class="op">,</span> x<span class="op">[</span><span class="dv">0</span><span class="op">],</span> x<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  tRosetta<span class="op">.</span>Draw<span class="op">(</span><span class="st">&quot;ALP&quot;</span><span class="op">);</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  CRosetta<span class="op">.</span>Update<span class="op">();</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  gSystem<span class="op">-&gt;</span>ProcessEvents<span class="op">();</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Wait for 1 ms</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>this_thread::sleep_for<span class="op">(</span><span class="bu">std::</span>chrono::milliseconds<span class="op">(</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Step to the next point</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> integratore<span class="op">-&gt;</span>Passo<span class="op">(</span>t<span class="op">,</span> x<span class="op">,</span> h<span class="op">,</span> f<span class="op">);</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>  t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Potete ovviamente usare queste tecniche anche per gli esercizi precedenti.</p>
<h1 id="esercizio-8.6">Esercizio 8.6 - Moto di una particella carica in un campo elettrico e magnetico uniforme</h1>
<p>Implementare la risoluzione dell‚Äôequazione del moto di una particella carica in un magnetico uniforme. Disegnare la traiettoria della particella e determinarne il diametro dell‚Äôorbita. Cosa succede se si aggiunge un campo elettrico con componente lungo l‚Äôasse z pari a <span class="math inline">E_z = -1000\,\text{V/m}</span>?</p>
<h2 id="moto-in-campo-elettrico-e-magnetico-uniformi">Moto in campo elettrico e magnetico uniformi</h2>
<p>Il moto di una particella carica in un campo elettrico e magnetico uniformi risente della forza di Lorentz e pertanto √® descritto dall‚Äôequazione <span class="math display">
m\ddot{x}(t) = q E + q v\times B,
</span> che si pu√≤ riscrivere in forma matriciale come <span class="math display">
\frac{\mathrm{d}}{\mathrm{d}t} \begin{pmatrix}
x\\ y\\ z\\ v_x\\ v_y\\ v_z
\end{pmatrix} =
\begin{pmatrix}
0&amp; 0&amp; 0&amp; 1&amp; 0&amp; 0\\
0&amp; 0&amp; 0&amp; 0&amp; 1&amp; 0\\
0&amp; 0&amp; 0&amp; 0&amp; 0&amp; 1\\
0&amp; 0&amp; 0&amp; 0&amp; \frac{q}m B_z&amp; -\frac{q}m B_y\\
0&amp; 0&amp; 0&amp; -\frac{q}m B_z&amp; 0&amp; \frac{q}m B_x\\
0&amp; 0&amp; 0&amp; \frac{q}m B_y&amp; -\frac{q}m B_x&amp; 0
\end{pmatrix}
\begin{pmatrix}
x\\ y\\ z\\ v_x\\ v_y\\ v_z
\end{pmatrix} +
\begin{pmatrix}
0\\ 0\\ 0\\ \frac{q}m E_x\\ \frac{q}m E_y\\ \frac{q}m E_z
\end{pmatrix}.
</span> √à un problema tridimensionale, e richiede quindi uno spazio delle fasi a sei dimensioni. Bisogner√† quindi usare tipi <code>std::array&lt;double, 6&gt;</code>.</p>
<p>Consideriamo il moto nel piano <span class="math inline">(x, y)</span> di un elettrone in un campo magnetico costante con i seguenti valori:</p>
<ul>
<li><span class="math inline">q = -1.60217653\times 10^{-19}\,\text{C}</span>;</li>
<li><span class="math inline">m = 9.1093826\times10^{-31}\,\text{kg}</span>;</li>
<li><span class="math inline">v_x(0) = 8\times10^6\,\text{m/s}</span>;</li>
<li><span class="math inline">B_z = 5\times10^{-3}\,\text{T}</span>;</li>
<li><span class="math inline">E_z = -1000\,\text{V/m}</span>;</li>
<li>tutte le altre componenti di campi e velocit√† iniziali sono nulle.</li>
</ul>
<p>Questi parametri corrispondono grosso modo all‚Äôapparato sperimentale per la misura di <span class="math inline">e/m</span> del laboratorio del II anno.</p>
<h2 id="risultati-attesi-4">Risultati attesi</h2>
<p>Per prima cosa potremmo cercare di disegnare la traiettoria nel piano <span class="math inline">(x, y)</span>:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/r.png" /></p>
<p>e poi (a titolo di esempio) l‚Äôandamento della coordinata z in funzione del tempo:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/z.png" /></p>
<p>√à infine possibile visualizzare la traiettoria della particella in tre dimensioni:</p>
<p><img src="https://labtnds.docs.cern.ch/Lezione8/pictures/elica.png" /></p>
<p>Per rappresentare la traiettoria dell‚Äôelettrone con <a href="https://github.com/ziotom78/gplotpp">gplot++</a> si pu√≤ usare la funzione <a href="https://github.com/ziotom78/gplotpp?tab=readme-ov-file#3d-plots">plot3d</a>, salvando i punti della traiettoria in tre vettori di <code>double</code>. Con ROOT si pu√≤ invece utilizzare la classe <a href="https://root.cern.ch/doc/master/classTGraph2D.html">TGraph2D</a>.</p>
<h1 id="errori-comuni">Errori comuni</h1>
<p>Come di consueto, elenco alcuni errori molto comuni che ho trovato negli anni passati correggendo gli esercizi che gli studenti hanno consegnato all‚Äôesame:</p>
<ul>
<li><p>Attenti a come gestite il tempo <span class="math inline">t</span>: se la simulazione deve terminare dopo 70¬†s ed usate un passo <span class="math inline">h</span> non rappresentabile esattamente da un numero floating-point (ad esempio, <code>t = 0.1</code>), pu√≤ essere che non avvenga mai che <code>t == 70.0</code>, ma <code>t == 69.9999999</code> a causa di arrotondamenti. Fate riferimento al <a href="https://ziotom78.github.io/tnds-notebooks/lezione08">notebook Julia</a>, dove si spiega come implementare un ciclo in modo robusto, calcolando ad esempio il numero di step necessari <strong>prima</strong> del ciclo.</p></li>
<li><p>Se seguite il testo originale degli esercizi e implementate tutto il codice di questa lezione usando <code>std::vector</code> anzich√© <code>std::array</code>, fate molta attenzione al numero di elementi in ogni vettore che usate all‚Äôinterno di un calcolo come <code>a + b</code>: se <code>a</code> ha 2 dimensioni ma <code>b</code> ne ha 3, √® un errore e i risultati del vostro programma saranno sbagliati! Dovete implementare un controllo esplicito sulla consistenza della dimensione di <code>a</code> e di <code>b</code> per <strong>tutti</strong> gli operatori, perch√© a differenza di <code>std::array</code> il compilatore non lo fa per voi.</p></li>
<li><p>Attenzione al fattore <span class="math inline">1/6</span> nel codice del metodo Runge-Kutta: se scrivete <code>1 / 6</code> nel vostro codice C++, il risultato √® zero! (Divisione tra due interi)</p></li>
<li><p>Nell‚Äô<a href="http://0.0.0.0:8000/carminati-esercizi-08.html#esercizio-8.3">esercizio 8.3</a> bisogna risolvere pi√π volte l‚Äôequazione del pendolo col metodo Runge-Kutta. Attenzione a resettare ogni volta le variabili! Dopo aver risolto l‚Äôequazione per una certa ampiezza iniziale <span class="math inline">A</span>, bisogna resettare sia il tempo <code>t</code> a zero che la variabile <code>x</code>, in modo che questa contenga di nuovo la condizione iniziale (con un valore diverso di <span class="math inline">A</span>), prima di far ripartire il Runge-Kutta.</p></li>
<li><p>Questi esercizi richiedono di passare una serie di parametri numerici dalla linea di comando. Assicuratevi di stampare una buona documentazione se l‚Äôutente non li specifica, e fate magari in modo che il comando <code>make esegui</code> avvii il vostro programma con parametri sensati.</p>
<p>Ecco un buon esempio:</p>
<pre><code>$ ./esercizio_9.4
Uso: esercizio_9.4 passo_h omega0 alpha omega_forzante

  passo_h           Intervallo di integrazione con RK [s]
  omega0            Frequenza di oscillazione [rad/s]
  alpha             Coefficiente di smorzamento [s‚Åª¬π]
  omega_forzante    Frequenza della forzante [rad/s]

$ make esegui
./esercizio_9.4 1e-2 10 0.033333 5
... [segue l&#39;output del programma]</code></pre></li>
</ul>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
