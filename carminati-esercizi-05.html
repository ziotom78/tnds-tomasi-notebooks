<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="it-IT" xml:lang="it-IT">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Leonardo Carminati" />
  <meta name="author" content="Maurizio Tomasi" />
  <title>Lezione 5: Classi ed ereditarietà</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Lezione 5: Classi ed ereditarietà</h1>
<blockquote class="metadata">
<p class="author">
      Leonardo CarminatiMaurizio Tomasi
  </p>
<p class="date before-toc"><time datetime="A.A. 2024−2025">A.A. 2024−2025</time></p>
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#esercizio-5.0" id="toc-esercizio-5.0">Esercizio 5.0 - Creazione della classe Posizione</a>
  <ul>
  <li><a href="#header-file-della-classe" id="toc-header-file-della-classe">Header file della classe</a></li>
  <li><a href="#file-di-implementazione-delle-classe" id="toc-file-di-implementazione-delle-classe">File di implementazione delle classe</a></li>
  <li><a href="#esempio-di-programma" id="toc-esempio-di-programma">Esempio di programma</a></li>
  <li><a href="#incapsulamento-e-data-hiding" id="toc-incapsulamento-e-data-hiding">Incapsulamento e <em>data hiding</em></a></li>
  <li><a href="#una-nota-sui-distruttori" id="toc-una-nota-sui-distruttori">Una nota sui distruttori</a></li>
  </ul></li>
  <li><a href="#esercizio-5.1" id="toc-esercizio-5.1">Esercizio 5.1 - Creazione della classe Particella ed Elettrone</a>
  <ul>
  <li><a href="#classe-particella" id="toc-classe-particella">Classe <code>Particella</code></a></li>
  <li><a href="#classe-elettrone" id="toc-classe-elettrone">Classe <code>Elettrone</code></a></li>
  <li><a href="#esempio-di-programma-1" id="toc-esempio-di-programma-1">Esempio di programma</a></li>
  <li><a href="#domanda" id="toc-domanda">Domanda</a></li>
  </ul></li>
  <li><a href="#esercizio-5.2" id="toc-esercizio-5.2">Esercizio 5.2 - Creazione delle classi <code>CampoVettoriale</code> e <code>PuntoMateriale</code></a>
  <ul>
  <li><a href="#header-file-della-classe-campovettoriale" id="toc-header-file-della-classe-campovettoriale">Header file della classe <code>CampoVettoriale</code></a></li>
  <li><a href="#header-file-della-classe-puntomateriale" id="toc-header-file-della-classe-puntomateriale">Header file della classe <code>PuntoMateriale</code></a></li>
  </ul></li>
  <li><a href="#esercizio-5.3" id="toc-esercizio-5.3">Esercizio 5.3 - Calcolo del campo elettrico generato da un dipolo (da consegnare)</a>
  <ul>
  <li><a href="#esempio-di-programma-2" id="toc-esempio-di-programma-2">Esempio di programma</a></li>
  <li><a href="#il-makefile" id="toc-il-makefile">Il <code>Makefile</code></a></li>
  <li><a href="#leggi-di-potenza" id="toc-leggi-di-potenza">Leggi di potenza</a></li>
  <li><a href="#creazione-di-plot" id="toc-creazione-di-plot">Creazione di plot</a></li>
  </ul></li>
  <li><a href="#esercizio-5.4" id="toc-esercizio-5.4">Esercizio 5.4 - Campo di multipolo (approfondimento)</a></li>
  <li><a href="#esercizio-5.5" id="toc-esercizio-5.5">Esercizio 5.5 - Gravità dallo spazio (approfondimento)</a>
  <ul>
  <li><a href="#grafici" id="toc-grafici">Grafici</a></li>
  </ul></li>
  <li><a href="#errori-comuni" id="toc-errori-comuni">Errori comuni</a></li>
  </ul>
</nav>

<main>
<p>[La pagina con la spiegazione originale degli esercizi si trova qui: <a href="https://labtnds.docs.cern.ch/Lezione5/Lezione5/" class="uri">https://labtnds.docs.cern.ch/Lezione5/Lezione5/</a>.]</p>
<p>In questa quinta lezione vogliamo affrontare un semplice problema di elettrostatica utilizzando un codice numerico. In particolare, vogliamo calcolare il campo elettrico generato da un dipolo. Vedremo poi come il codice si può estendere in modo immediato a problemi più complessi (ad esempio per studiare il campo generato da un multi-polo o il campo gravitazionale generato da un sistema di masse). Nell’affrontare questo problema fisico approfondiremo il concetto di ereditarietà in C++. Come al solito dovremo prima preparare un set di classi utili per lo svolgimento dell’esercizio.</p>
<h1 id="esercizio-5.0">Esercizio 5.0 - Creazione della classe Posizione</h1>
<p>Implementare una classe <code>Posizione</code> che descriva un punto nello spazio seguendo queste indicazioni:</p>
<ol>
<li>Come data membri privati usare la terna di coordinate cartesiane.</li>
<li>Definire un costruttore di default che crei un punto di coordinate (0,0,0).</li>
<li>Definire un costruttore che abbia come argomento una terna di numeri <code>double</code> corrispondenti alle coordinate del punto.</li>
<li>Definire metodi per restituire le coordinate del punto in sistemi di coordinate cartesiane, sferiche e cilindriche.</li>
<li>Definire un metodo che calcoli la distanza da un altro punto.</li>
</ol>
<p>Verificare il funzionamento della classe creando un programmino che legga da riga di comando le coordinate cartesiane di un punto e ne stampi le coordinate in un sistema di coordinate sferiche e cilindriche.</p>
<h2 id="header-file-della-classe">Header file della classe</h2>
<p>Nell’header file <code>posizione.h</code> vanno dichiarati tutti i metodi ed i data membri. Si noti come i data membri siano tutti privati: questa modo di disegnare le classi implementa il concetto di <em>incapsulamento</em> e <em>data hiding</em> in C++.</p>
<p>Un paio di punti già che vale la pena ricordare:</p>
<ol>
<li>Il qualificatore <code>const</code> dopo la dichiarazione di una funzione informa che la funzione non modificherà il contenuto dell’oggetto. In maniera simile il qualificatore <code>const</code> nell’argomento di <code>Distanza</code> specifica che il metodo <code>Distanza</code> non modificherà il suo argomento. È sempre utile specificare esplicitamente queste proprietà dei metodi.</li>
<li>L’insieme dell direttive <code>#ifndef</code>, <code>#define</code>, <code>#endif</code> serve per proteggersi da inclusioni incrociate (molto comuni quando si utilizzano diverse classi che interagiscono tra di loro). Nelle <a href="./tomasi-lezione-02.html#pragma-once">slide</a> abbiamo però visto che <code>#pragma once</code> è un modo più semplice di ottenere lo stesso risultato che mette al riparo da tanti potenziali errori.</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Posizione <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Con `= default= si dice al C++ di implementare un costruttore</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// di default. Qui possiamo farlo perché più sotto abbiamo definito</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// un valore iniziale per tutti i data membri (m_x, m_y, m_z).</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  Posizione<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  Posizione<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Distruttore. È completamente inutile, ma lo mettiamo come esempio</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>Posizione<span class="op">();</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Avremmo anche potuto scrivere:</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">//   ~Posizione() = default;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// e così facendo non avremmo dovuto definire il distruttore nel file .cpp</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// metodi</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getX<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">// Coordinate cartesiane</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getY<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getZ<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getR<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">// Coordinate sferiche</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getPhi<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getTheta<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getRho<span class="op">()</span> <span class="at">const</span><span class="op">;</span> <span class="co">// raggio delle coordinate cilindriche</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> Distanza<span class="op">(</span><span class="at">const</span> Posizione <span class="op">&amp;)</span> <span class="at">const</span><span class="op">;</span> <span class="co">// distanza da un altro punto</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_x</span><span class="op">{},</span> <span class="va">m_y</span><span class="op">{},</span> <span class="va">m_z</span><span class="op">{};</span>  <span class="co">// Inizializzo a zero</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="file-di-implementazione-delle-classe">File di implementazione delle classe</h2>
<p>Qui vediamo un esempio di implementazione della classe (file <code>posizione.cpp</code>). Per prima cosa è definito il costruttore con parametri ed il distruttore, che in questo caso è vuoto (nei costruttori di <code>Posizione</code> non ci sono operazioni di allocazione dinamica della memoria, quindi non è necessario implementare regole di distruzione particolari). Noi definiamo comunque il distruttore, perché questo è un esempio didattico; solitamente per classi così semplici però il distruttore si tralascia se il suo corpo è vuoto (<code>{}</code>). Successivamente sono implementati tutti i metodi descritti nell’header file:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;posizione.h&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Non c’è bisogno di implementare `Posizione::Posizione`, perché</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">// con `= default` diciamo al C++ di implementarlo da solo</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Costruttore a partire da una terna cartesiana</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>Posizione<span class="op">::</span>Posizione<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">)</span> <span class="op">:</span> <span class="va">m_x</span><span class="op">{</span>x<span class="op">},</span> <span class="va">m_y</span><span class="op">{</span>y<span class="op">},</span> <span class="va">m_z</span><span class="op">{</span>z<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Distruttore (è vuoto, ragion per cui di solito si evita di definirlo,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co">// tranne che nelle classi che possono essere derivate)</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>Posizione<span class="op">::~</span>Posizione<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Coordinate cartesiane</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getX<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_x</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getY<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_y</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getZ<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_z</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co">//////////////////////////////////////////////////////////////////////</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Coordinate sferiche</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getR<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sqrt<span class="op">(</span><span class="va">m_x</span> <span class="op">*</span> <span class="va">m_x</span> <span class="op">+</span> <span class="va">m_y</span> <span class="op">*</span> <span class="va">m_y</span> <span class="op">+</span> <span class="va">m_z</span> <span class="op">*</span> <span class="va">m_z</span><span class="op">);</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getPhi<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> atan2<span class="op">(</span><span class="va">m_y</span><span class="op">,</span> <span class="va">m_x</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getTheta<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> acos<span class="op">(</span><span class="va">m_z</span> <span class="op">/</span> getR<span class="op">());</span> <span class="op">}</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co">//////////////////////////////////////////////////////////////////////</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co">// Raggio delle coordinate cilindriche</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>getRho<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> sqrt<span class="op">(</span><span class="va">m_x</span> <span class="op">*</span> <span class="va">m_x</span> <span class="op">+</span> <span class="va">m_y</span> <span class="op">*</span> <span class="va">m_y</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co">//////////////////////////////////////////////////////////////////////</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a><span class="co">// Distanza da un altro punto</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> Posizione<span class="op">::</span>Distanza<span class="op">(</span><span class="at">const</span> Posizione <span class="op">&amp;</span>b<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sqrt<span class="op">(</span>pow<span class="op">(</span>getX<span class="op">()</span> <span class="op">-</span> b<span class="op">.</span>getX<span class="op">(),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>              pow<span class="op">(</span>getY<span class="op">()</span> <span class="op">-</span> b<span class="op">.</span>getY<span class="op">(),</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>              pow<span class="op">(</span>getZ<span class="op">()</span> <span class="op">-</span> b<span class="op">.</span>getZ<span class="op">(),</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="esempio-di-programma">Esempio di programma</h2>
<p>Questo programma utilizza la nuova classe appena creata: richiede di fornire come argomenti le tre coordinate cartesiane e poi stampa le terne di coordinate cartesiane, sferiche e cilindriche.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;posizione.h&quot;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Questo programma richiede da riga di comando le coordinate x, y e z di</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">// un punto e ne restituisce le coordinate sferiche e cilindiriche.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Controlla gli argomenti</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>argc <span class="op">!=</span> <span class="dv">4</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span>cerr<span class="op">,</span> <span class="st">&quot;Usage: </span><span class="sc">{}</span><span class="st"> X Y Z&quot;</span><span class="op">,</span> argv<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> x<span class="op">{</span>stod<span class="op">(</span>argv<span class="op">[</span><span class="dv">1</span><span class="op">])};</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> y<span class="op">{</span>stod<span class="op">(</span>argv<span class="op">[</span><span class="dv">2</span><span class="op">])};</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> z<span class="op">{</span>stod<span class="op">(</span>argv<span class="op">[</span><span class="dv">3</span><span class="op">])};</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Crea un oggetto posizione ed accede ai vari metodi</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  Posizione P<span class="op">{</span>x<span class="op">,</span> y<span class="op">,</span> z<span class="op">};</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Coordinate cartesiane: </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>          P<span class="op">.</span>getX<span class="op">(),</span> P<span class="op">.</span>getY<span class="op">(),</span> P<span class="op">.</span>getZ<span class="op">());</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Coordinate cilindriche: </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>          P<span class="op">.</span>getRho<span class="op">(),</span> P<span class="op">.</span>getPhi<span class="op">(),</span> P<span class="op">.</span>getZ<span class="op">());</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Coordinate sferiche: </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>          P<span class="op">.</span>getR<span class="op">(),</span> P<span class="op">.</span>getPhi<span class="op">(),</span> P<span class="op">.</span>getTheta<span class="op">());</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questo è un esempio di output del programma:</p>
<pre><code>$ ./test 1 2 5
Coordinate cartesiane: 1, 2, 5
Coordinate cilindriche: 2.23606797749979, 1.1071487177940904, 5
Coordinate sferiche: 5.477225575051661, 1.1071487177940904, 0.420534335283965</code></pre>
<h2 id="incapsulamento-e-data-hiding">Incapsulamento e <em>data hiding</em></h2>
<p>Utilizziamo l’esempio della classe <code>Posizione</code> per riflettere sul concetto di <em>incapsulamento</em>. La nostra classe “nasconde” i dati principali (le tre coordinate nel caso specifico) in un set di data-membri privati (<code>m_x</code>, <code>m_y</code>, <code>m_z</code>). Tali data-membri non sono per definizione accessibili al programma principale in modo diretto, ma solo attraverso una serie di metodi pubblici (interfacce) che proteggono il dato da un utilizzo incontrollato. Inoltre la protezione del dato dietro interfacce pubbliche mette al riparo da possibili cambiamenti o correzioni nel design di una classe.</p>
<p>Per fare un esempio, supponiamo che per qualche ragione l’autore della classe decida che è meglio rappresentare la posizione utilizzando una terna di numeri che corrispondono alle coordinate sferiche. Se l’autore della classe adegua di conseguenza le interfacce pubbliche, un eventuale utilizzatore della classe (il nostro <code>main</code>) non si accorgerebbe della variazione. Se invece il <code>main</code> avesse avuto libero accesso alle tre coordinate e le avesse utilizzate direttamente, il cambiamento di design della classe avrebbe richiesto cambiamenti anche nel <code>main</code>.</p>
<h2 id="una-nota-sui-distruttori">Una nota sui distruttori</h2>
<p>L’implementazione esplicita di un distruttore è spesso necessaria per evitare <em>memory leaks</em> quando il costruttore alloca dinamicamente memoria. In caso contrario tipicamente il distruttore sarà vuoto e può essere omesso. Ricordiamoci che se il distruttore viene dichiarato nell’header file della classe allora dobbiamo necessariamente fornirne una implementazione (anche vuota). In questo caso in <code>posizione.h</code> ci basta scrivere:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="op">~</span>Posizione<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span></code></pre></div>
<p>oppure</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">~</span>Posizione<span class="op">()</span> <span class="op">{}</span></span></code></pre></div>
<h1 id="esercizio-5.1">Esercizio 5.1 - Creazione della classe Particella ed Elettrone</h1>
<p>Definiamo due classi che ci permetteranno di rappresentare le sorgenti del campo (elettrico in questo caso).</p>
<ul>
<li>Costruiamo una classe <code>Particella</code> caratterizzata dall’avere una massa ed una carica, quindi dotata dei seguenti metodi:
<ol>
<li>Un construttore avente come argomenti massa e carica.</li>
<li>Dei metodi di accesso ai valori di massa e carica.</li>
<li>Un metodo per stampare tali valori.</li>
</ol></li>
<li>Siccome vogliamo che questa classe sia la classe base di altre classi, dichiareremo i data membri come <code>protected</code>.</li>
<li>Costruiamo, attraverso il meccanismo di ereditarietà, una classe derivata <code>Elettrone</code> che, essendo una <code>Particella</code> di massa e carica note (i cui valori sono riportati su <a href="http://it.wikipedia.org/wiki/Elettrone">wikipedia</a>), ha il solo costruttore di default, che inizializza correttamente i data membri. Modifichiamo il metodo di stampa in modo che indichi che si tratta di un elettrone.</li>
</ul>
<p>Verifichiamo che le nuovi classi e l’ereditarietà funzioni correttamente:</p>
<ol>
<li>Istanziamo dinamicamente un oggetto per ogni classe.</li>
<li>Verifichiamo che su tutti questi operino i metodi accessori di massa e carica di <code>Particella</code>, ma il metodo di stampa delle classi derivate.</li>
</ol>
<h2 id="classe-particella">Classe <code>Particella</code></h2>
<p>Questo è l’header <code>particella.h</code> per la classe <code>Particella</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">// Classe astratta per una generica particella</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Definisce i metodi che ogni particella</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">// deve implementare e delle funzioni di utilizzo generale.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Particella <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Costruttori</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  Particella<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  Particella<span class="op">(</span><span class="dt">double</span> massa<span class="op">,</span> <span class="dt">double</span> carica<span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Distruttore di default</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>Particella<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Metodi</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> GetMassa<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_massa</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> GetCarica<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_carica</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> Print<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_massa</span><span class="op">{};</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_carica</span><span class="op">{};</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Implementazione nel file <code>particella.cpp</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Metodi per la classe base</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>Particella<span class="op">::</span>Particella<span class="op">(</span><span class="dt">double</span> massa<span class="op">,</span> <span class="dt">double</span> carica<span class="op">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">:</span> <span class="va">m_massa</span><span class="op">{</span>massa<span class="op">},</span> <span class="va">m_carica</span><span class="op">{</span>carica<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Particella<span class="op">::</span>Print<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Particella: m = </span><span class="sc">{}</span><span class="st">, q = </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="va">m_massa</span><span class="op">,</span> <span class="va">m_carica</span><span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="classe-elettrone">Classe <code>Elettrone</code></h2>
<p>File header <code>elettrone.h</code> per la classe <code>Elettrone</code> (in questo caso scegliamo di tenere tutto nel file <code>.h</code>, e non c’è bisogno quindi di creare un file <code>elettrone.cpp</code>: molto più comodo!):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Implementazione concreta di una particella elementare</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">// In questo caso tutte le proprietà della particella</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">// sono costanti, definite nel costruttore di default.</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Elettrone <span class="op">:</span> <span class="kw">public</span> Particella <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Costruttore</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  Elettrone<span class="op">()</span> <span class="op">:</span> Particella<span class="op">{</span><span class="fl">9.1093826e-31</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.60217653e-19</span><span class="op">}</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Invoco il costruttore della classe base con i parametri</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">// opportuni,  ma poi non c&#39;e&#39; altro da fare</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Distruttore di default</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>Elettrone<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> Print<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;Elettrone: m = </span><span class="sc">{}</span><span class="st">, q = </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="va">m_massa</span><span class="op">,</span> <span class="va">m_carica</span><span class="op">);</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="esempio-di-programma-1">Esempio di programma</h2>
<p>Questo programma utilizza le nuove classi appena create. Verifica il funzionamento dell’ereditarietà e la dereferenziazione dei puntatori a classe.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;particella.h&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `a` è una variabile di tipo `Particella`</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  Particella a<span class="op">{</span><span class="fl">1.</span><span class="op">,</span> <span class="fl">1.6E-19</span><span class="op">};</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `e` è un *puntatore* a una variabile di tipo `Elettrone`</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  Elettrone <span class="op">*</span>e<span class="op">{</span><span class="kw">new</span> Elettrone<span class="op">{}};</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Metodi della classe base. Notare che qui la sintassi è `a.NOMEMETODO(…)`</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Particella con massa </span><span class="sc">{}</span><span class="st"> kg e carica </span><span class="sc">{}</span><span class="st"> C&quot;</span><span class="op">,</span> a<span class="op">.</span>GetMassa<span class="op">(),</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>          a<span class="op">.</span>GetCarica<span class="op">());</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  a<span class="op">.</span>Print<span class="op">();</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Metodi della classe derivata. Qui invece la sintassi è</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `e-&gt;NOMEMETODO(…)` e non `e.NOMEMETODO(…)`,</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">// perché `e` è un puntatore</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;Elettrone con massa </span><span class="sc">{}</span><span class="st"> kg e carica </span><span class="sc">{}</span><span class="st"> C&quot;</span><span class="op">,</span> e<span class="op">-&gt;</span>GetMassa<span class="op">(),</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>          e<span class="op">-&gt;</span>GetCarica<span class="op">());</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>  e<span class="op">-&gt;</span>Print<span class="op">();</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  Particella b<span class="op">{</span>a<span class="op">};</span>  <span class="co">// costruisco una Particella a partire da una Particella</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>  Particella d<span class="op">{*</span>e<span class="op">};</span> <span class="co">// costruisco una Particella a partire da un Elettrone</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>  Elettrone f<span class="op">{</span>d<span class="op">};</span>   <span class="co">// costruisco un Elettrone a partire da una Particella</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="domanda">Domanda</h2>
<p>Il programma di esempio contiene un errore: provate a capire da cosa è causato.</p>
<h1 id="esercizio-5.2">Esercizio 5.2 - Creazione delle classi <code>CampoVettoriale</code> e <code>PuntoMateriale</code></h1>
<p>Per risolvere problemi relativi all’elettrostatica o alla gravità, modelliamo il programma usando due elementi: una rappresentazione del campo vettoriale e una rappresentazione delle sorgenti dei campi vettoriali.</p>
<p>Definiremo quindi una classe <code>CampoVettoriale</code>: sono molti i casi in fisica in cui un vettore è collegato ad un punto dello spazio. Ad esempio: una forza ha un punto di applicazione, o i vettori del campo elettrico e campo gravitazionale hanno un valore che varia da punto a punto dello spazio.</p>
<p>Questo esercizio richiede di costruire una classe <code>CampoVettoriale</code>, che erediti dalla classe <code>Posizione</code> e che aggiunga:</p>
<ol>
<li><p>le tre componenti di un vettore alla posizione;</p></li>
<li><p>i metodi per accedere e/o modificare il vettore;</p></li>
<li><p>costruttori: in particolare, il costruttore <code>CampoVettoriale(const Posizione&amp;)</code> che crei un vettore nullo nella posizione assegnata;</p></li>
<li><p>un metodo <code>double Modulo() const</code> che restituisca la lunghezza del vettore;</p></li>
<li><p>overloading di <code>operator+</code> e <code>operator+=</code> in modo da poter facilmente sommare campi.</p></li>
</ol>
<h2 id="header-file-della-classe-campovettoriale">Header file della classe <code>CampoVettoriale</code></h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;posizione.h&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CampoVettoriale <span class="op">:</span> <span class="kw">public</span> Posizione <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  CampoVettoriale<span class="op">(</span><span class="at">const</span> Posizione <span class="op">&amp;);</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  CampoVettoriale<span class="op">(</span><span class="at">const</span> Posizione <span class="op">&amp;,</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">double</span> Fx<span class="op">,</span> <span class="dt">double</span> Fy<span class="op">,</span> <span class="dt">double</span> Fz<span class="op">);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  CampoVettoriale<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">,</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">double</span> Fx<span class="op">,</span> <span class="dt">double</span> Fy<span class="op">,</span> <span class="dt">double</span> Fz<span class="op">);</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Distruttore (vuoto, si può tralasciare)</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>CampoVettoriale<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Operatore di incremento</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span><span class="op">+=(</span><span class="at">const</span> CampoVettoriale <span class="op">&amp;);</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getFx<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_Fx</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getFy<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_Fy</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> getFz<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_Fz</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">[[</span><span class="at">nodiscard</span><span class="op">]]</span> <span class="dt">double</span> Modulo<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_Fx</span><span class="op">,</span> <span class="va">m_Fy</span><span class="op">,</span> <span class="va">m_Fz</span><span class="op">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="co">// Somma di due campi vettoriale, implementata stavolta in</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="co">// una funzione che sta *fuori* da `CampoVettoriale` anziché</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="co">// in un metodo di `CampoVettoriale`. Vedi sotto la spiegazione</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> CampoVettoriale <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> CampoVettoriale <span class="op">&amp;</span>a<span class="op">,</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">const</span> CampoVettoriale <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">// …</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Abbiamo scelto di implementare la somma di due campi vettoriali come una <em>funzione</em> anziché un metodo, quindi non è definita all’interno delle parentesi graffe di <code>class CampoVettoriale : public Posizione { … }</code>. Sarebbe stato possibile definire un metodo in base al fatto che per il compilatore C++ la scrittura</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span></code></pre></div>
<p>è equivalente a</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a<span class="op">.</span><span class="kw">operator</span><span class="op">+(</span>b<span class="op">);</span></span></code></pre></div>
<p>Avremmo quindi potuto definire un metodo</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>CampoVettoriale CampoVettoriale<span class="op">::</span><span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> CampoVettoriale <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// …</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questa pratica è però scoraggiata negli operatori binari commutativi come la somma, perché è poco leggibile: infatti a differenza della forma funzionale, <code>a</code> non è esplicito in questo caso (equivale a <code>*this</code>). Inoltre quest’asimmetria tra <code>b</code> (argomento esplicito) e <code>*this</code> (argomento implicito) non riflette il fatto che la somma è un’operazione commutativa, e quindi i ruoli del primo e del secondo operando sono paritari.</p>
<h3 id="overloading-operatori">Overloading operatori</h3>
<p>Per risolvere facilmente questo tipo di problemi è molto utile ridefinire gli operatori <code>operator+</code> e <code>operator+=</code> per la classe <code>CampoVettoriale</code>. Di seguito una possibile implementazione comoda di questo overloading. Notate che nell’operatore <code>operator+</code> viene creato un nuovo vettore (<code>sum</code>) che viene restituito <em>by value</em>. Per <code>operator+=</code> invece la modifica viene effettuata sull’oggetto che chiama l’operatore. L’oggetto stesso (modificato) viene poi restituito <em>by reference</em>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">inline</span> CampoVettoriale <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> CampoVettoriale <span class="op">&amp;</span>a<span class="op">,</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">const</span> CampoVettoriale <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Si potrebbe anche usare `are_close` qui, visto che</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// le coordinate sono numeri double e sono quindi soggette</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ad arrotondamenti…</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">((</span>a<span class="op">.</span>getX<span class="op">()</span> <span class="op">!=</span> b<span class="op">.</span>getX<span class="op">())</span> <span class="op">||</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>a<span class="op">.</span>getY<span class="op">()</span> <span class="op">!=</span> b<span class="op">.</span>getY<span class="op">())</span> <span class="op">||</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">(</span>a<span class="op">.</span>getZ<span class="op">()</span> <span class="op">!=</span> b<span class="op">.</span>getZ<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>      println<span class="op">(</span>cerr<span class="op">,</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;Somma di campi vettoriali in punti diversi non ammessa&quot;</span><span class="op">);</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>      exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  CampoVettoriale sum<span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>getX<span class="op">(),</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>getY<span class="op">(),</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>getZ<span class="op">(),</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>getFx<span class="op">()</span> <span class="op">+</span> b<span class="op">.</span>getFx<span class="op">(),</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>getFy<span class="op">()</span> <span class="op">+</span> b<span class="op">.</span>getFy<span class="op">(),</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>getFz<span class="op">()</span> <span class="op">+</span> b<span class="op">.</span>getFz<span class="op">(),</span></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a><span class="co">// Ricordare che, se `v` e `w` sono due oggetti di tipo `CampoVettoriale`, allora</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a><span class="co">//    w += v;</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="co">// viene considerato dal compilatore C++ come</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="co">//    w.operator+=(v);</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> CampoVettoriale<span class="op">::</span><span class="kw">operator</span><span class="op">+=(</span><span class="at">const</span> CampoVettoriale <span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non c&#39;è bisogno di usare le funzioni getFx(), getFy(), getFz():</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// siamo in un metodo di CampoVettoriale, quindi abbiamo accesso</span></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ai membri privati (non è così per operator+ definito sopra)</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>  <span class="va">m_Fx</span> <span class="op">+=</span> v<span class="op">.</span><span class="va">m_Fx</span><span class="op">;</span></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>  <span class="va">m_Fy</span> <span class="op">+=</span> v<span class="op">.</span><span class="va">m_Fy</span><span class="op">;</span></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>  <span class="va">m_Fz</span> <span class="op">+=</span> v<span class="op">.</span><span class="va">m_Fz</span><span class="op">;</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In alcuni codici si può trovare l’operatore di incremento che restituisce un <em>reference</em> all’istanza stessa della classe che ha subito l’incremento (<code>*this</code>):</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>CampoVettoriale <span class="op">&amp;</span> CampoVettoriale<span class="op">::</span><span class="kw">operator</span><span class="op">+=(</span><span class="at">const</span> CampoVettoriale <span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// …</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Il fatto di tornare un <code>CampoVettoriale &amp;</code> anziché un <code>void</code> permette di usare la scrittura</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">+=</span> b<span class="op">;</span></span></code></pre></div>
<p>che per il compilatore C++ è equivalente a</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a<span class="op">.</span><span class="kw">operator</span><span class="op">+=(</span>b<span class="op">);</span></span></code></pre></div>
<p>e corrisponde ai seguenti passaggi:</p>
<ol type="1">
<li><p>Incremento di <code>a</code> del campo <code>b</code> (<code>a += b</code>);</p></li>
<li><p>Una volta che <code>a</code> è stato incrementato, assegnamento del valore risultante a <code>c</code> (<code>c = a</code>, dove <code>a</code> è il nuovo valore dopo l’incremento).</p></li>
</ol>
<p>Noi non useremo <em>mai</em> la scrittura <code>c = a += b</code>, perché è difficile da leggere e mai realmente utile; è infatti più leggibile spezzare la riga in due istruzioni:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">+=</span> b<span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a<span class="op">;</span></span></code></pre></div>
<p>N.B.: per entrambe le classi di cui sopra, sentitevi liberi di aggiungere tutti i metodi addizionali che ritenete utili per risolvere questo esercizio o i successivi.</p>
<h2 id="header-file-della-classe-puntomateriale">Header file della classe <code>PuntoMateriale</code></h2>
<p>La classe <code>PuntoMateriale</code> ci servirà per rappresentare le sorgenti dei campi.</p>
<h3 id="ereditarietà-multipla">Ereditarietà multipla</h3>
<p>In C++, una classe può ereditare da più di una classe madre. In questo caso mantiene le proprietà (metodi e data membri) di tutte le classi madri. Nell’header file <code>puntomateriale.h</code> vanno elencate tutte le classi da cui si vuole ereditare, specificando la modalità con cui si vuole ereditare (<code>public</code>, <code>private</code> o <code>protected</code>):</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#pragma once</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;particella.h&quot;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;posizione.h&quot;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PuntoMateriale <span class="op">:</span> <span class="kw">public</span> Particella<span class="op">,</span> <span class="kw">public</span> Posizione <span class="op">{</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// …</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>La nuova classe avrà, per esempio, definiti sia i metodi <code>GetMassa()</code> e <code>GetCarica()</code> di <code>Particella</code> e anche <code>GetX()</code>, <code>GetR()</code>, … di <code>Posizione</code>.</p>
<h3 id="utilizzo-di-costruttori-delle-classi-madri">Utilizzo di costruttori delle classi madri</h3>
<p>Specialmente nel caso di ereditarietà multipla, è buona norma utilizzare i costruttori già esistenti della classe madre. Tali costruttori possono venire chiamati esplicemente dando il nome della classe madre seguito dagli argomenti opportuni. Ad esempio, siccome esistono i costruttori di <code>Posizione</code> con le tre coordinate cartesiane, e di <code>Particella</code> con massa e carica, possiamo definire un costruttore:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>PuntoMateriale<span class="op">(</span><span class="dt">double</span> massa<span class="op">,</span> <span class="dt">double</span> carica<span class="op">,</span> <span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">);</span></span></code></pre></div>
<p>la cui implementazione è data da:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>PuntoMateriale<span class="op">::</span>PuntoMateriale<span class="op">(</span><span class="dt">double</span> massa<span class="op">,</span> <span class="dt">double</span> carica<span class="op">,</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">)</span> <span class="op">:</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    Particella<span class="op">{</span>massa<span class="op">,</span> carica<span class="op">},</span> Posizione<span class="op">{</span>x<span class="op">,</span> y<span class="op">,</span> z<span class="op">}</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// nothing more to be done !</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Come si può notare in questo esempio la costruzione di <code>PuntoMateriale</code> è completamente delegata ai costruttori delle classi madre.</p>
<h1 id="esercizio-5.3">Esercizio 5.3 - Calcolo del campo elettrico generato da un dipolo (da consegnare)</h1>
<p>Possiamo ora utilizzare quanto realizzato sopra per affrontare un interessante problema di elettrostatica, ovvero lo studio del campo elettrico generato da un dipolo. Sviluppiamo un codice che costuisca un dipolo costituito da un elettrone e un protone posizionati ad una distanza <span class="math inline">\delta = 10^{-10}\,\text{m}</span> e determini:</p>
<ol>
<li>il valore del campo elettrico di dipolo prodotto in un punto <span class="math inline">P</span> le cui coordinate sono inserite da linea di comando;</li>
<li>disegni l’andamento del modulo del campo elettrico lungo l’asse del dipolo per una distanza da 100 a 1000 volte <span class="math inline">\delta</span>. Che tipo di andamento ha il campo? (Fate riferimento all’approfondimento seguente sulle leggi di potenza qui sotto).</li>
</ol>
<h2 id="esempio-di-programma-2">Esempio di programma</h2>
<p>Questo programma utilizza le nuove classi appena create: richiede di fornire come argomenti le tre coordinate cartesiane e poi stampa il campo elettrico di dipolo richiesto dall’esercizio [primo punto]:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;puntomateriale.h&quot;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;campovettoriale.h&quot;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;print&gt;</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> e<span class="op">{</span><span class="fl">1.60217653E-19</span><span class="op">};</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> me<span class="op">{</span><span class="fl">9.1093826E-31</span><span class="op">};</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> mp<span class="op">{</span><span class="fl">1.67262171E-27</span><span class="op">};</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> d<span class="op">{</span><span class="fl">1.E-10</span><span class="op">};</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span> argv<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>argc <span class="op">!=</span> <span class="dv">4</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>      println<span class="op">(</span>cerr<span class="op">,</span> <span class="st">&quot;Usage: </span><span class="sc">{}</span><span class="st"> &lt;x&gt; &lt;y&gt; &lt;z&gt;&quot;</span><span class="op">,</span> argv<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>      exit<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> x<span class="op">{</span>stod<span class="op">(</span>argv<span class="op">[</span><span class="dv">1</span><span class="op">])};</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> y<span class="op">{</span>stod<span class="op">(</span>argv<span class="op">[</span><span class="dv">2</span><span class="op">])};</span></span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> z<span class="op">{</span>stod<span class="op">(</span>argv<span class="op">[</span><span class="dv">3</span><span class="op">])};</span></span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>  Posizione r<span class="op">{</span>x<span class="op">,</span>y<span class="op">,</span>z<span class="op">};</span></span>
<span id="cb23-25"><a href="#cb23-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-26"><a href="#cb23-26" aria-hidden="true" tabindex="-1"></a>  PuntoMateriale elettrone<span class="op">{</span>me<span class="op">,</span> <span class="op">-</span>e<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span>  d <span class="op">/</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb23-27"><a href="#cb23-27" aria-hidden="true" tabindex="-1"></a>  PuntoMateriale protone  <span class="op">{</span>mp<span class="op">,</span>  e<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span>d <span class="op">/</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb23-28"><a href="#cb23-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-29"><a href="#cb23-29" aria-hidden="true" tabindex="-1"></a>  CampoVettoriale E<span class="op">{</span>elettrone<span class="op">.</span>CampoElettrico<span class="op">(</span>r<span class="op">)</span> <span class="op">+</span> protone<span class="op">.</span>CampoElettrico<span class="op">(</span>r<span class="op">)};</span></span>
<span id="cb23-30"><a href="#cb23-30" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;E = (</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="st">) N/C&quot;</span><span class="op">,</span> E<span class="op">.</span>getFx<span class="op">(),</span> E<span class="op">.</span>getFy<span class="op">(),</span> E<span class="op">.</span>getFz<span class="op">());</span></span>
<span id="cb23-31"><a href="#cb23-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-32"><a href="#cb23-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-33"><a href="#cb23-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A partire da questo esempio completare le richieste dell’esercizio:</p>
<ul>
<li><p>Si aggiunga un ciclo che permetta di calcolare il campo a distanze via via crescenti</p></li>
<li><p>Si aggiunga eventualmente un grafico per visualizzare l’andamento del campo in funzione della distanza dal centro del dipolo. Potete usare ROOT o <a href="miscellanea.html#gplotinstall">gplot++</a>.</p></li>
</ul>
<h2 id="il-makefile">Il <code>Makefile</code></h2>
<p>Il numero di classi sta proliferando e quindi anche il <code>Makefile</code> diventa sempre più articolato. Questo è il <code>Makefile</code> per chi usa gplot++:</p>
<pre class="make"><code>CXXFLAGS=-g -Wall -Wextra -Werror --pedantic -std=c++23

esercizio_5.3: esercizio_5.3.o posizione.o puntomateriale.o campovettoriale.o particella.o
       g++ -o $@ $^

esercizio_5.3.o: esercizio_5.3.cpp particella.h puntomateriale.h posizione.h campovettoriale.h
       g++ -c $&lt; -o $@ ${CXXFLAGS}

particella.o: particella.cpp particella.h
       g++ -c $&lt; -o $@ ${CXXFLAGS}

posizione.o: posizione.cpp posizione.h
       g++ -c $&lt; -o $@ ${CXXFLAGS}

puntomateriale.o: puntomateriale.cpp puntomateriale.h posizione.h particella.h
       g++ -c $&lt; -o $@ ${CXXFLAGS}

campovettoriale.o: campovettoriale.cpp campovettoriale.h posizione.h
       g++ -c $&lt; -o $@ ${CXXFLAGS}

clean:
       rm -f *.o

esegui:
       # Esegui il programma con argomenti di esempio
       ./esercizio_5.3 1e-10 2e-10 3e-10</code></pre>
<p>L’aspetto più noioso dei <code>Makefile</code> è la necessità di elencare tutti i file <code>.h</code> dopo il file <code>.cpp</code>; ma al giorno d’oggi si usano strumenti più avanzati di <code>make</code>, come <a href="https://cmake.org/">CMake</a> o <a href="https://mesonbuild.com/index.html">Meson</a>, che automatizzano molto di quanto nei <code>Makefile</code> va specificato manualmente.</p>
<p>Nel caso in cui decidiate di implementare tutte le classi nei file <code>.h</code> e di non usare quindi file <code>.cpp</code> (ottima scelta!), il <code>Makefile</code> si semplifica moltissimo. Ecco un esempio, sempre assumendo che usiate gplot++:</p>
<pre class="make"><code>CXXFLAGS=-g -Wall -Wextra -Werror --pedantic -std=c++23

esercizio_5.3: esercizio_5.3.cpp posizione.h puntomateriale.h campovettoriale.h particella.h
       g++ -o $@ $&lt; ${CXXFLAGS}

clean:
       rm -f *.o

esegui:
       # Esegui il programma con argomenti di esempio
       ./esercizio_5.3 1e-10 2e-10 3e-10</code></pre>
<p>Questa invece è la versione nel caso di ROOT, che è più complicata perché bisogna eseguire due volte <code>root-config</code>, ricordarsi di usare nei punti appropriati le variabili <code>INCS</code> e <code>LIBS</code>, e disabilitare il controllo dei warning:</p>
<pre class="make"><code>INCS=`root-config --cflags`
LIBS=`root-config --libs`
# Do not use -Werror with ROOT, because it will complain that you
# want to use C++23
CXXFLAGS=-g -Wall -Wextra --pedantic -std=c++23

esercizio_5.3: esercizio_5.3.o posizione.o puntomateriale.o campovettoriale.o particella.o
       g++ -o $@ $^ ${LIBS}

esercizio_5.3.o: esercizio_5.3.cpp particella.h puntomateriale.h posizione.h campovettoriale.h
       g++ -c $&lt; -o $@ ${INCS} ${CXXFLAGS}

particella.o: particella.cpp particella.h
       g++ -c $&lt; -o $@ ${INCS} ${CXXFLAGS}

posizione.o: posizione.cpp posizione.h
       g++ -c $&lt; -o $@ ${INCS} ${CXXFLAGS}

puntomateriale.o: puntomateriale.cpp puntomateriale.h posizione.h particella.h
       g++ -c $&lt; -o $@ ${INCS} ${CXXFLAGS}

campovettoriale.o: campovettoriale.cpp campovettoriale.h posizione.h
       g++ -c $&lt; -o $@ ${INCS} ${CXXFLAGS}

clean:
       rm -f *.o

esegui:
       # Esegui il programma con argomenti di esempio
       ./esercizio_5.3 1e-10 2e-10 3e-10</code></pre>
<h2 id="leggi-di-potenza">Leggi di potenza</h2>
<p>Se un campo ha un andamento <span class="math inline">E = k R^\alpha</span> e valutiamo il campo in due punti diversi <span class="math inline">R_1</span> e <span class="math inline">R_2</span>: <span class="math display">
  E_1 = E(R_1), \qquad E_2 = E(R_2),
</span> allora possiamo ricavare <span class="math inline">\alpha</span> dalla relazione <span class="math display">
  \alpha = \frac{\log\bigl(E_1 / E_2\bigr)}{\log\bigl(R_1 / R_2\bigr)}
</span></p>
<h2 id="creazione-di-plot">Creazione di plot</h2>
<p>Per creare il grafico potete usare <a href="https://github.com/ziotom78/gplotpp">gplot++</a>, che funziona sotto Mac e Linux ed è semplice da installare anche sotto Windows. Come già spiegato la scorsa settimana, dovete innanzitutto <a href="https://github.com/ziotom78/gplotpp#installing-gnuplot-and-gploth">installare Gnuplot</a>; se avete Windows ma usate la WSL, eseguite <code>sudo apt install gnuplot</code>, altrimenti seguite <a href="https://github.com/ziotom78/gplotpp#windows">questa avvertenza</a>.</p>
<p>Una volta installato Gnuplot, scaricate nella directory del vostro esercizio il file <a href="https://raw.githubusercontent.com/ziotom78/gplotpp/master/gplot%2B%2B.h"><code>gplot++.h</code></a>, oppure se usate Linux o Mac eseguite questa linea di comando nella directory del vostro esercizio:</p>
<p><input type="text" value="curl 'https://raw.githubusercontent.com/ziotom78/gplotpp/master/gplot%2B%2B.h' > gplot++.h" id="installGplotpp" readonly="1" size="60"><button onclick='copyFmtInstallationScript("installGplotpp")'>Copia</button></p>
<p>Per produrre un grafico di <span class="math inline">E = E(r)</span> con <a href="https://github.com/ziotom78/gplotpp">gplot++</a>, dovete salvare le ascisse e le ordinate dei punti del grafico in due <code>std::vector</code>, e poi chiamare il metodo <code>Gnuplot::plot(x, y)</code>.</p>
<p>Di seguito viene riportato un esempio:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;gplot++.h&quot;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> delta<span class="op">{</span><span class="fl">1e-10</span><span class="op">};</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Siccome questo programma non richiede di leggere parametri dalla linea di</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="co">// comando, non c&#39;è bisogno di specificare `argc` e `argv`. (Se lo faceste,</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">// la compilazione fallirebbe perché né `argc` né `argv` sarebbero usati).</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> d_vec<span class="op">;</span> <span class="co">// Vettore delle distanze (asse x)</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> E_vec<span class="op">;</span> <span class="co">// Vettore dei moduli del campo elettrico (asse y)</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Questo ciclo &quot;for&quot; calcola il valore del campo per 90 punti,</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// da 100δ a 1000δ in passi di 10δ</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">double</span> dist<span class="op">{</span><span class="dv">100</span> <span class="op">*</span> delta<span class="op">};</span> dist <span class="op">&lt;=</span> <span class="dv">1000</span> <span class="op">*</span> delta<span class="op">;</span> dist <span class="op">+=</span> <span class="dv">10</span> <span class="op">*</span> delta<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Il vettore `d_vec` è usato per la stampa a video e il plot, non per i</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// calcoli, quindi è meglio salvare il dato in nm anziché m (è più leggibile).</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    d_vec<span class="op">.</span>push_back<span class="op">(</span>dist <span class="op">*</span> <span class="fl">1e9</span><span class="op">);</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Inserire qui il codice che calcola il modulo del campo alla distanza</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `dist`</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> e_field<span class="op">{...};</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>    E_vec<span class="op">.</span>push_back<span class="op">(</span>e_field<span class="op">);</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Stampa anche a video: è sempre bene farlo per controllare i numeri!</span></span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>    println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{:.5e}</span><span class="st"> </span><span class="sc">{:.5e}</span><span class="st">&quot;</span><span class="op">,</span> dist<span class="op">,</span> e_field<span class="op">);</span></span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>  Gnuplot plt<span class="op">{};</span></span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-35"><a href="#cb27-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Togliere questa riga se si preferisce che il grafico appaia in una finestra</span></span>
<span id="cb27-36"><a href="#cb27-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">// interattiva</span></span>
<span id="cb27-37"><a href="#cb27-37" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>redirect_to_png<span class="op">(</span><span class="st">&quot;esercizio05.3.png&quot;</span><span class="op">);</span></span>
<span id="cb27-38"><a href="#cb27-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-39"><a href="#cb27-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Disegna le ascisse usando una scala bilogaritmica, così che y ∝ 1/r³ viene</span></span>
<span id="cb27-40"><a href="#cb27-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">// trasformato in una legge lineare y&#39; = ξ − 3r&#39;, con y&#39; = log(y), r&#39; = log(r).</span></span>
<span id="cb27-41"><a href="#cb27-41" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_logscale<span class="op">(</span>Gnuplot<span class="op">::</span>AxisScale<span class="op">::</span>LOGXY<span class="op">);</span></span>
<span id="cb27-42"><a href="#cb27-42" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Distance [nm]&quot;</span><span class="op">);</span></span>
<span id="cb27-43"><a href="#cb27-43" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;Electric field [N/C]&quot;</span><span class="op">);</span></span>
<span id="cb27-44"><a href="#cb27-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-45"><a href="#cb27-45" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>plot<span class="op">(</span>d_vec<span class="op">,</span> E_vec<span class="op">);</span></span>
<span id="cb27-46"><a href="#cb27-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-47"><a href="#cb27-47" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Non dimenticare la chiamata a `show`, altrimenti il grafico non</span></span>
<span id="cb27-48"><a href="#cb27-48" aria-hidden="true" tabindex="-1"></a>  <span class="co">// verrà salvato/visualizzato</span></span>
<span id="cb27-49"><a href="#cb27-49" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb27-50"><a href="#cb27-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questo è il risultato atteso:</p>
<p><img src="./images/esercizio05.3.png" /></p>
<p>Notare che la pendenza della retta sul grafico bilogaritmico è −3, perché per <strong>un</strong> ordine di grandezza in più sull’asse <span class="math inline">x</span> (da 10 a 100 nm) ci sono <strong>tre</strong> ordini di grandezza in meno (da <span class="math inline">5 \times 10^5</span> a <span class="math inline">500\,\text{N/C}</span>) sull’asse <span class="math inline">y</span>. Questo corrisponde al fatto che se <span class="math inline">r \gg \delta</span> allora <span class="math display">
\left|E_\text{dipolo}(r)\right| = \left|k\frac{q^+}{(r + \delta)^2} + k\frac{q^-}{(r - \delta)^2}\right|
= \left|k\frac{e}{(r + \delta)^2} - k\frac{e}{(r - \delta)^2}\right| \approx \frac{4 k e \delta}{r^3} \propto r^{-3}.
</span></p>
<p>Se invece volete usare ROOT, dovete usare la classe <code>TGraph</code>; fate riferimento a <a href="http://labmaster.mi.infn.it/Laboratorio2/labTNDS/lectures_1819/lezioneROOT_1819.html">questa spiegazione</a>.</p>
<h1 id="esercizio-5.4">Esercizio 5.4 - Campo di multipolo (approfondimento)</h1>
<p>Scrivere un programma che calcoli il campo elettrico generato da un multipolo di ordine <span class="math inline">n</span>. In questo esercizio, un <span class="math inline">n</span>-polo (con <span class="math inline">n</span> pari) è una distribuzione di <span class="math inline">n</span> particelle, in cui la particella <span class="math inline">k</span>-esima ha carica <span class="math inline">(-1)^k e</span>, dove <span class="math inline">e</span> è la carica del protone, e si trova nel punto <span class="math display">
P_k = \left(r_0 \cos\left(\frac{2\pi k}n\right), r_0 \sin\left(\frac{2\pi k}n\right)\right)
</span> dove <span class="math inline">r_0</span> è il raggio a cui sono messe le cariche.</p>
<ul>
<li><p>Verificare che a grande distanza (<span class="math inline">R \gg r_0</span>) il campo elettrico varia proporzionalmente a <span class="math inline">R^{-2 - n/2}</span>.</p></li>
<li><p>Valutare fino a quali valori di <span class="math inline">n</span> si riesce a verificare questa dipendenza.</p></li>
</ul>
<p>Questo è un problema abbastanza interessante, perché bisogna scegliere una distanza abbastanza grande perché sia valido il comportamento asintotico, ma abbastanza ridotta per evitare problemi di arrotondamento nella somma di molti termini di segno contrario.</p>
<h1 id="esercizio-5.5">Esercizio 5.5 - Gravità dallo spazio (approfondimento)</h1>
<p>Il <a href="http://www.goceitaly.asi.it/GoceIT/">satellite GOCE</a> si trova in orbita a 250 km dalla superficie terrestre e dotato di accelerometri in grado di misurare variazioni dell’accelerazione di gravità fino a <span class="math inline">\delta g / g = 10^{-13}</span>. Lo scopo della missione includeva una mappatura dettagliata del campo gravitazionale terrestre, prodotto dalle distribuzioni non omogenee di massa. Costruire un programma che:</p>
<ol>
<li>calcoli l’accelerazione di gravità sul satellite per una Terra perfettamene sferica e dimensioni pari al raggio medio (<a href="http://it.wikipedia.org/wiki/Terra">wikipedia</a>).</li>
<li>calcoli la variazione relativa di g prodotta da una catena montuosa, schematizzata come una fila di 100 sfere di 1 km di raggio poste sopra la superficie media della Terra (usare 3000 kg/m³ come densità della roccia) e produca un grafico della variazione in funzione della posizione del satellite sull’orbita.</li>
</ol>
<p>Per risolvere questo esercizio si costruisca dapprima il sistema di sorgenti di campo (Terra e catena montuosa). Si calcoli il campo generato da tutte le sorgenti in un punto a distanza dal centro della terra pari al raggio terrestre più la distanza del satellite dalla superficie terrestre. Muovere questo punto in modo che percorra tutta l’orbita (in passi da 10 Km).</p>
<p><img src="http://labmaster.mi.infn.it/Laboratorio2/labTNDS/lectures_1819/figure/schema_montagne.png" /></p>
<h2 id="grafici">Grafici</h2>
<p>Nel creare un grafico dell’andamento della distorsione dell’accelerazione gravitazionale <span class="math inline">\delta g / g</span> è meglio usare la scala logaritmica sull’asse <span class="math inline">y</span>, visto che il valore di <span class="math inline">\delta g/g</span> varia di diversi ordini di grandezza:</p>
<p><img src="./images/esercizio05.5.png" /></p>
<p>La posizione del picco dipende dal punto rispetto all’angolo zero in cui sono state poste le sfere che rappresentano la catena montuosa. Nel grafico qui sopra, la montagna <span class="math inline">k</span>-esima è stata posta ad un angolo <span class="math inline">\theta_k = 90^\circ + k \delta\theta</span>, con <span class="math inline">k = 0\ldots 99</span> e <span class="math inline">\delta\theta = 1\,\text{km} / 2\pi R_T</span> l’incremento angolare associato a sfere di raggio 1 km e poste sulla superficie terrestre, con <span class="math inline">R_T</span> raggio medio della Terra.</p>
<h1 id="errori-comuni">Errori comuni</h1>
<p>Come di consueto, elenco alcuni errori molto comuni che ho trovato negli anni passati correggendo gli esercizi che gli studenti hanno consegnato all’esame:</p>
<ul>
<li><p>L’errore di gran lunga più comune è sbagliare l’implementazione della formula del campo, che oggettivamente è complicata! Riguardate in particolare queste cose:</p>
<ol>
<li><p>Unità di misura delle costanti;</p></li>
<li><p>Attenzione a come scrivete i numeri in notazione scientifica! Il numero <span class="math inline">10^{-4}</span> si scrive <code>1e-4</code>, <strong>non</strong> <code>10e-4</code>, perché la scrittura <code>1e-4</code> indica effettivamente <span class="math inline">1 \times 10^{-4}</span>, così come <code>7.5e-3</code> indica <span class="math inline">7.5\times 10^{-3}</span>.</p></li>
<li><p>Verificate che ciò che deve stare al numeratore stia veramente al numeratore, e idem per il denominatore!</p></li>
<li><p>Ovviamente, il campo di una singola carica deve andare come <span class="math inline">1/r^2</span>! Eppure un bel po’ di studenti consegnano codice che non segue neppure questa semplice proprietà…</p></li>
<li><p>Quando calcolate la distanza <span class="math inline">d</span> tra due posizioni, assicuratevi di restituire <span class="math inline">d</span> e non <span class="math inline">d^2</span> (errore molto comune!).</p></li>
</ol></li>
<li><p>Stranamente, ogni anno più di uno studente sbaglia a implementare <code>operator+</code> per i vettori, e invece di calcolare <code>z = v + w</code> calcola in realtà <code>z = v + v = 2v</code>, oppure <code>z = w + w = 2w</code>.</p></li>
<li><p>Nel leggere la posizione <code>x y z</code> a cui calcolare il campo del dipolo da linea di comando, assicuratevi di usare la funzione <a href="https://en.cppreference.com/w/cpp/string/basic_string/stof"><code>std::stod</code></a> oppure <a href="https://cplusplus.com/reference/cstdlib/atof/"><code>std::atof</code></a>, anziché <code>std::stoi</code> o <code>std::atoi</code>, perché queste ultime due restituiscono valori interi.</p></li>
</ul>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
