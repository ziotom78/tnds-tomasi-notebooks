<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="it-IT" xml:lang="it-IT">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Maurizio Tomasi" />
  <title>Temi d’esame svolti</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
  <script src="./fmtinstall.js"></script>
</head>
<body>

<header>
<h1 class="title">Temi d’esame svolti</h1>
<blockquote class="metadata">
<p class="author">
      Maurizio Tomasi
  </p>
<p class="date before-toc"><time datetime="A.A. 2024−2025">A.A. 2024−2025</time></p>
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#premessa" id="toc-premessa">Premessa</a></li>
  <li><a href="#alcuni-trucchi-sempre-utili" id="toc-alcuni-trucchi-sempre-utili">Alcuni trucchi sempre utili</a>
  <ul>
  <li><a href="#uso-di-struct" id="toc-uso-di-struct">Fare a meno dell’incapsulamento</a></li>
  <li><a href="#template" id="toc-template">Usare i template al posto di gerarchie di classi</a></li>
  <li><a href="#functori" id="toc-functori">Functori</a></li>
  </ul></li>
  <li><a href="#temaA" id="toc-temaA">Tema 1 (stima di integrali)</a>
  <ul>
  <li><a href="#letturaTestoA" id="toc-letturaTestoA">Lettura del testo</a></li>
  <li><a href="#temaApuntoA" id="toc-temaApuntoA">Implementazione del punto 1</a></li>
  <li><a href="#temaApuntoB" id="toc-temaApuntoB">Implementazione del punto 2</a></li>
  <li><a href="#temaApuntoCD" id="toc-temaApuntoCD">Implementazione dei punti 3 e 4</a></li>
  <li><a href="#temaApuntoE" id="toc-temaApuntoE">Implementazione del punto 5</a></li>
  <li><a href="#temaApuntoF" id="toc-temaApuntoF">Implementazione del punto 6</a></li>
  <li><a href="#temaApuntoG" id="toc-temaApuntoG">Implementazione del punto 7</a></li>
  </ul></li>
  <li><a href="#temaB" id="toc-temaB">Tema 2 (equazioni differenziali)</a>
  <ul>
  <li><a href="#temaBLetturaTesto" id="toc-temaBLetturaTesto">Lettura del testo</a></li>
  <li><a href="#temaBpuntoA" id="toc-temaBpuntoA">Implementazione del punto 1</a></li>
  <li><a href="#temaBpuntoB" id="toc-temaBpuntoB">Implementazione del punto 2</a></li>
  <li><a href="#temaBpuntoC" id="toc-temaBpuntoC">Implementazione del punto 3</a></li>
  <li><a href="#temaBpuntoD" id="toc-temaBpuntoD">Implementazione del punto 4</a></li>
  <li><a href="#temaBpuntoE" id="toc-temaBpuntoE">Implementazione del punto 5</a></li>
  </ul></li>
  <li><a href="#temaC" id="toc-temaC">Tema 3 (equazioni differenziali, Monte Carlo)</a>
  <ul>
  <li><a href="#lettura-del-testo" id="toc-lettura-del-testo">Lettura del testo</a></li>
  <li><a href="#temaCpuntoA" id="toc-temaCpuntoA">Implementazione del punto 1</a></li>
  <li><a href="#temaCpuntoB" id="toc-temaCpuntoB">Implementazione del punto 2</a></li>
  <li><a href="#temaCpuntoC" id="toc-temaCpuntoC">Implementazione del punto 3</a></li>
  </ul></li>
  <li><a href="#temaD" id="toc-temaD">Tema 4 (integrali, ricerca di zeri)</a>
  <ul>
  <li><a href="#lettura-del-testo-1" id="toc-lettura-del-testo-1">Lettura del testo</a></li>
  <li><a href="#temaDpuntoA" id="toc-temaDpuntoA">Implementazione del punto 1</a></li>
  <li><a href="#temaDpuntoB" id="toc-temaDpuntoB">Implementazione del punto 2</a></li>
  <li><a href="#temaDpuntoC" id="toc-temaDpuntoC">Implementazione del punto 3</a></li>
  </ul></li>
  <li><a href="#temaE" id="toc-temaE">Tema 5 (simulazione di un esperimento)</a>
  <ul>
  <li><a href="#lettura-del-testo-2" id="toc-lettura-del-testo-2">Lettura del testo</a></li>
  <li><a href="#temaEpuntoA" id="toc-temaEpuntoA">Implementazione del punto 1</a></li>
  <li><a href="#temaEpuntoB" id="toc-temaEpuntoB">Implementazione del punto 2</a></li>
  <li><a href="#temaEpuntoC" id="toc-temaEpuntoC">Implementazione del punto 3</a></li>
  <li><a href="#temaEpuntoD" id="toc-temaEpuntoD">Implementazione del punto 4</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<p>In questa pagina fornisco indicazioni utili allo svolgimento dei temi d’esame messi a disposizione da Carminati alla pagina <a href="https://labtnds.docs.cern.ch/ProveEsame/TemiEsame/" class="uri">https://labtnds.docs.cern.ch/ProveEsame/TemiEsame/</a>.</p>
<h1 id="premessa">Premessa</h1>
<p>Prima di discutere come svolgere i temi d’esame proposti da Carminati, vi fornisco qualche informazione di massima che si applica a ciascuno dei temi:</p>
<ul>
<li><p>Non fornisco qui l’implementazione completa, perché ciò significherebbe condividere anche delle routine che devono essere implementate nel corso dell’anno da ciascuno studente (es., il metodo di bisezione, l’integrazione col metodo del punto medio, il metodo di Runge-Kutta…).</p></li>
<li><p>Non ripeto concetti già spiegati a lezione, ed assumo anzi che chi legge questa pagina abbia già una buona infarinatura della teoria ed abbia svolto e sistemato tutti gli esercizi.</p></li>
<li><p>In ogni tema uso tecniche un po’ diverse da quelle che avete visto a lezione; di solito, queste varianti che vi mostro servono per rendere il codice più veloce da scrivere (importante nell’esame scritto, dove avete a disposizione solo due ore!).</p></li>
<li><p>Assumo che ciascuno di voi usi lo standard C++20: questo significa usare il flag <code>-std=c++20</code> con il compilatore.</p></li>
<li><p>Nei miei svolgimento non uso ROOT, ma Gnuplot interfacciato con la libreria <a href="https://github.com/ziotom78/gplotpp">gplot++</a>: lo trovo molto più semplice e veloce da usare. Fate riferimento a <a href="index.html#gplotinstall">questo link</a> per sapere come installarlo sul vostro computer</p></li>
<li><p>Similmente, uso <code>cout</code> e <code>cerr</code> solo nei casi più semplici, mentre quando si tratta di stampare numeri formattati uso la libreria <a href="https://github.com/fmtlib/fmt">fmt</a>. Fate riferimento a <a href="index.html#fmtinstall">questo link</a> per maggiori informazioni.</p></li>
<li><p>Siete caldamente invitati a tenere presente i punti elencati al link <a href="index.html#esamescritto">Come prepararsi all’esame scritto</a> mentre leggete questa pagina!</p></li>
</ul>
<h1 id="alcuni-trucchi-sempre-utili">Alcuni trucchi sempre utili</h1>
<p>Nello svolgimento dei temi d’esame presentato sotto faccio spesso ricorso ad alcuni trucchi, che illustro una volta per tutte in questa sezione</p>
<h2 id="uso-di-struct">Fare a meno dell’incapsulamento</h2>
<p>Nell’<a href="carminati-esercizi-05.html#esercizio-5.0">esercizio 5.0</a> abbiamo visto come si implementa una classe rispettando il principio dell’<em>incapsulamento</em>, in cui i dati della classe non sono direttamente accessibili all’esterno:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Posizione <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// costruttori</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  Posizione<span class="op">();</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  Posizione<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">);</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// distruttore</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">~</span>Posizione<span class="op">();</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// metodi</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> getX<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_x</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> getY<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_x</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> getZ<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">m_z</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// […]</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Distanza<span class="op">(</span><span class="at">const</span> Posizione <span class="op">&amp;)</span> <span class="at">const</span><span class="op">;</span> <span class="co">// distanza da un altro punto</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Dall&#39;esterno è impossibile accedere a questi campi</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_x</span><span class="op">,</span> <span class="va">m_y</span><span class="op">,</span> <span class="va">m_z</span><span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Questo è utile nel caso in cui si decida in futuro di cambiare il modo in cui la classe è implementata internamente. L’idea è che se si impedisce a chi usa la classe di sapere che le coordinate sono salvate in tre variabili chiamate <code>m_x</code>, <code>m_y</code> e <code>m_z</code>, sarà più facile cambiare poi la rappresentazione interna in qualcosa d’altro; ad esempio, si potrebbe cambiare la classe in modo che internamente si mantengano le coordinate sferiche, e <code>getX()</code>, <code>getY()</code> e <code>getZ()</code> ritornino quindi le componenti X/Y/Z calcolandone al volo la conversione da sferiche a cartesiane.</p>
<p>Tuttavia, implementare le classi in questo modo richiede un sacco di tempo e forza a compiere molte ripetizioni, aumentando la possibilità di errore. (Nell’esempio sopra, c’è un errore nel codice, ve ne eravate accorti?). L’idea dell’incapsulamento è quella di rendere il codice più facilmente modificabile in un futuro possibilmente lontano, ma il vostro esame scritto viene sviluppato giusto nel paio di ore richieste per la prova: l’incapsulamento è quindi inutile, oltre che potenzialmente dannoso per il tempo che vi fa sprecare.</p>
<p>Se volete definire una classe nel codice dell’esame, vi consiglio di farlo nel modo più rapido possibile:</p>
<ol>
<li><p>Definite tutti i metodi e i campi dati <code>public</code>.</p></li>
<li><p>Non implementate funzioni <code>get*()</code> e <code>set*()</code>, perché se tutti i dati sono pubblici non servono.</p></li>
<li><p>Evitate di definire i distruttori, a meno che non usiate <code>new</code> nel costruttore (non è il caso di <code>Posizione</code>, e in <strong>nessuno</strong> dei temi d’esame che abbiamo dato negli ultimi dieci anni è stato mai indispensabile usare <code>new</code>).</p></li>
<li><p>Potete anche evitare di definire i costruttori: in tal caso il C++ ne implementerà uno di default, in cui vengono richiesti i valori di tutte le variabili membro. In altre parole, la classe</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Posizione <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    Posizione<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">,</span> <span class="dt">double</span> z<span class="op">)</span> <span class="op">:</span> <span class="va">m_x</span><span class="op">{</span>x<span class="op">},</span> <span class="va">m_y</span><span class="op">{</span>y<span class="op">},</span> <span class="va">m_z</span><span class="op">{</span>z<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_x</span><span class="op">,</span> <span class="va">m_y</span><span class="op">,</span> <span class="va">m_z</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>può essere abbreviata così:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Posizione <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_x</span><span class="op">,</span> <span class="va">m_y</span><span class="op">,</span> <span class="va">m_z</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>ed il costruttore che accetta tre parametri è automaticamente scritto dal compilatore C++. Comodo, no?</p></li>
<li><p>In C++ si possono fornire valori di default alle variabili membro della classe. In questo modo, se scrivete</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Posizione <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> <span class="va">m_x</span><span class="op">{</span><span class="fl">1.0</span><span class="op">},</span> <span class="va">m_y</span><span class="op">{</span><span class="fl">2.0</span><span class="op">},</span> <span class="va">m_z</span><span class="op">{</span><span class="fl">3.0</span><span class="op">};</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>potete poi creare una variabile <code>Posizione</code> e inizializzare le sue coordinate automaticamente:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    Posizione p<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span> <span class="co">// Inizializzata a (1, 2, 3)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    Posizione q<span class="op">{};</span>        <span class="co">// Idem!</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Forse non lo sapete, ma in C++ c’è una scorciatoia per definire una classe con membri pubblici: la parola chiave <code>struct</code>. La scrittura</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Posizione <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_x</span><span class="op">{},</span> <span class="va">m_y</span><span class="op">{},</span> <span class="va">m_z</span><span class="op">{};</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>è equivalente a</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Scrivo `struct` anziché `class`, così è tutto `public` di default</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Posizione <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="va">m_x</span><span class="op">{},</span> <span class="va">m_y</span><span class="op">{},</span> <span class="va">m_z</span><span class="op">{};</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>ma è più veloce da scrivere.</p></li>
</ol>
<p>Vi garantisco che il docente non si arrabbierà se usate questi accorgimenti e rinunciate all’incapsulamento: al massimo prenderà spunto dal vostro codice per chiedervi di parlare all’esame orale di “incapsulamento” da un punto di vista teorico, e se voi mostrerete di saperlo, il docente sarà ugualmente soddisfatto.</p>
<h2 id="template">Usare i template al posto di gerarchie di classi</h2>
<p>I template in C++ possono essere usati per rendere più veloce la programmazione, requisito importante in un esame scritto, ma richiedono di ripensare il codice scritto a lezione. Non è quindi una tecnica che raccomando a tutti, ma i più smaliziati possono trarre giovamento se re-implementano alcuni algoritmi degli esercizi usando i template.</p>
<p>Consideriamo l’<a href="carminati-esercizi-07.html#esercizio-7.0">esercizio 7.0</a>, che richiede di implementare il metodo di integrazione della media. A lezione è stato indicato di creare una classe <code>Integral</code>, una classe <code>FunzioneBase</code> e classi derivate da quest’ultima per ciascuna delle funzioni da integrare:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FunzioneBase <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">virtual</span> <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parabola <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Integral <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">virtual</span> <span class="dt">double</span> calculate<span class="op">(</span><span class="dt">int</span> step<span class="op">,</span> <span class="at">const</span> FunzioneBase <span class="op">&amp;</span> f<span class="op">)</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MidPoint <span class="op">:</span> <span class="kw">public</span> Integral <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> calculate<span class="op">(</span><span class="dt">int</span> step<span class="op">,</span> <span class="at">const</span> FunzioneBase <span class="op">&amp;</span> f<span class="op">)</span> <span class="kw">override</span><span class="op">;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>L’esercizio era ovviamente pensato per farvi capire il funzionamento dell’ereditarietà e del polimorfismo. È però possibile implementare l’algoritmo del midpoint senza usare né l’uno né l’altro, appoggiandosi ai template: in questo modo il codice diventa molto più semplice da scrivere ed usare:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Fn<span class="op">&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> midpoint<span class="op">(</span>Fn fn<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> accum<span class="op">{};</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x<span class="op">{</span>a <span class="op">+</span> <span class="op">(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> n<span class="op">)};</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    accum <span class="op">+=</span> fn<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> accum <span class="op">*</span> <span class="op">(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">/</span> n<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La definizione del template dice che <code>Fn</code> è un tipo che sarà specificato quando si invoca <code>midpoint</code>, e il tipo corrisponde a una funzione che accetta un <code>double</code> e restituisce un <code>double</code>, perché è così che viene impiegata la variabile <code>fn</code> nel ciclo <code>for</code>. Vediamo una cosa interessante: una variabile come <code>fn</code> in C++ può contenere non solo valori numerici o stringhe, ma addirittura una <em>funzione</em>.</p>
<p>Una volta definita la funzione template <code>midpoint()</code>, questa si usa in modo molto naturale:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> myfn<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">*</span> x <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;The integral is </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> midpoint<span class="op">(</span>myfn<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Spero che apprezzerete la brevità di questo codice: non c’è bisogno di creare una classe derivata <code>MyFn</code> né di creare una sua istanza <code>MyFn myfn{}</code> nel <code>main</code>. Nel nostro esempio, <code>myfn</code> è il nome di una funzione ma viene passato come parametro (di tipo <code>Fn</code> e di nome <code>fn</code>) alla funzione template; in altre parole, quando invochiamo <code>midpoint</code> così:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>midpoint<span class="op">(</span>myfn<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">)</span></span></code></pre></div>
<p>non scriviamo <code>myfn(…)</code> con le parentesi e un argomento al loro interno, scriviamo solo il nome della funzione perché non vogliamo invocarla ma solo passarla come parametro. Nel template <code>midpoint</code>, il compilatore C++ fa corrispondere il tipo <code>Fn</code> alla dichiarazione <code>double (double x)</code>, ossia una funzione che accetta un <code>double</code> e ritorna un <code>double</code>.</p>
<p>Questo tipo di funzione template è così diffuso che il C++20 consente di abbreviare la definizione</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Fn<span class="op">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> midpoint<span class="op">(</span>Fn fn<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>nel modo seguente, usando la parola chiave <code>auto</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> midpoint<span class="op">(</span><span class="kw">auto</span> fn<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>(È come se <code>auto</code> servisse per dire al compilatore: “non fare tante storie sul tipo di <code>fn</code>, decidi tu quale tipo ti va meglio!”).</p>
<p>Le due scritture sono equivalenti, ma la seconda è molto più veloce da scrivere. (Però dovete ricordare di usare un compilatore C++ abbastanza recente e passare il flag <code>-std=c++20</code>). Attenzione però che ogni <code>auto</code> che usate è un tipo diverso. Quindi la funzione</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> myfun<span class="op">(</span><span class="kw">auto</span> a<span class="op">,</span> <span class="kw">auto</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>non</strong> è equivalente a</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> myfun<span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span> <span class="op">{</span>   <span class="co">// `a` and `b` are of the same type</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>ma corrisponde invece a</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> myfun<span class="op">(</span>T a<span class="op">,</span> U b<span class="op">)</span> <span class="op">{</span>   <span class="co">// `a` and `b` can be of different types</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Se volete che <code>a</code> e <code>b</code> abbiano lo stesso tipo, allora non potete usare <code>auto</code> e dovete usare invece obbligatoriamente la parola chiave <code>template</code>.</p>
<p>Per quanto riguarda il punto in cui si <strong>usa</strong> il template, ossia quando nel nostro esempio viene invocato nel <code>main()</code>, se si usano le <a href="https://learn.microsoft.com/it-it/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">espressioni lambda</a>, si può addirittura fare a meno di definire la funzione <code>myfn()</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Shortest version ever: just five lines!!!</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;The integral is </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>               midpoint<span class="op">([](</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">*</span> x <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">4</span><span class="op">;</span> <span class="op">},</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>                        <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La strana scrittura <code>[](double x) { return ...; }</code> permette di definire “al volo” una funzione senza nome che accetta un parametro <code>double x</code> e restituisce un <code>double</code>, e passarla come argomento.</p>
<p>È facile vedere come l’esempio appena mostrato sia più asciutto e rapido da scrivere rispetto ad un approccio orientato agli oggetti:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parabola <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x <span class="op">*</span> x <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  Midpoint midpoint<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  Parabola myfun</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;The integral is </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>               Eval<span class="op">.</span>integrate<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> myfun<span class="op">));</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In questo caso (1) non possiamo usare le espressioni lambda, (2) dobbiamo definire una classe <code>Parabola</code>, e (3) dobbiamo nel <code>main()</code> dichiarare due variabili: il codice è lungo più del doppio!</p>
<p>Chi fosse interessato all’uso dei <code>template</code>, con un piccolo sforzo può convertire gli algoritmi visti a lezione (bisezione, midpoint, Simpson, Runge-Kutta…) in template tramite un banale copia-e-incolla e qualche piccolo aggiustamento (e la cancellazione di un bel po’ di roba che diventa inutile, come tutte le classi base), e raccoglierli tutti in un file <code>algoritmi.h</code>. Vi sorprenderete di quanto corto sarà questo file: i template consentono di condensare molto il codice! Questo file <code>algoritmi.h</code> vi sarà poi utile da includere nel vostro compito, anziché andare a cercare il codice di ogni singolo esercizio in mille sottocartelle.</p>
<p>Chi non si spaventa all’idea di usare i <code>template</code> e le espressioni lambda, con un po’ di pratica può guadagnare velocità nella scrittura del codice: cosa che, come ho già scritto, è molto utile durante gli scritti.</p>
<p><strong>Avvertenza</strong>: in linea di principio, con la definizione template di <code>midpoint()</code> si potrebbe pensare di poter calcolare l’integrale di <span class="math inline">f(x) = \sin x</span> passandogli direttamente la funzione <code>sin</code> definita in <code>&lt;cmath&gt;</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>midpoint<span class="op">(</span><span class="bu">std::</span>sin<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span>  <span class="co">// Doesn&#39;t work</span></span></code></pre></div>
<p>ma questo non funziona perché <code>&lt;cmath&gt;</code> definisce <a href="https://en.cppreference.com/w/cpp/numeric/math/sin">più funzioni</a> chiamate <code>sin()</code>: una per <code>float</code>, una per <code>double</code>, e una per <code>long double</code>. Nel template non è chiaro quale usare, e quindi il compilatore C++ si arrabbia. La soluzione più veloce è quella di racchiuderla in un’espressione lambda, in modo da esplicitare il tipo:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Works because we explicitly tell the compiler that we want `double sin(double x)`</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>midpoint<span class="op">([]</span> <span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>sin<span class="op">(</span>x<span class="op">);</span> <span class="op">},</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<p>Questo fastidioso inconveniente capita solo con le funzioni definite in <code>cmath</code>: quelle che definite voi non hanno di solito alcuna ambiguità.</p>
<h2 id="functori">Functori</h2>
<p>Nella sezione <a href="#template">Usare i template al posto di gerarchie di classi</a> ho mostrato che i <code>template</code> permettono di evitare la creazione di gerarchie di classi e l’uso del polimorfismo quando si devono implementare algoritmi che agiscono su <em>funzioni</em>.</p>
<p>L’approccio che usa i <code>template</code> può essere facilmente applicato a oggetti derivati da <code>FunzioneBase</code> o <code>FunzioneVettorialeBase</code> usando i cosiddetti “functori” (orribile anglicismo, il termine originale è <em>functor</em>).</p>
<p>Riprendiamo l’implementazione di <code>midpoint()</code> vista sopra:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> midpoint<span class="op">(</span><span class="kw">auto</span> fn<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> accum<span class="op">{};</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x<span class="op">{</span>a <span class="op">+</span> <span class="op">(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> n<span class="op">)};</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    accum <span class="op">+=</span> fn<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> accum <span class="op">*</span> <span class="op">(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">/</span> n<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Abbiamo visto che con questa definizione è possibile passare direttamente funzioni senza bisogno di creare classi derivate da <code>FunzioneBase</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> myfn<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x <span class="op">*</span> x <span class="op">-</span> <span class="dv">3</span> <span class="op">*</span> x <span class="op">+</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;The integral is </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> midpoint<span class="op">(</span>myfn<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Però ogni tanto potrebbe essere comodo invece usare le classi: ad esempio quando la funzione dipende da parametri, come nel caso in cui voglia esprimere una generica parabola <span class="math inline">f(x) = ax^2 + bx + c</span>. Con il vecchio approccio basato sugli oggetti, è banale farlo: nel caso della parabola, basta creare una classe che abbia tre variabili membro <code>a</code>, <code>b</code> e <code>c</code>. Ecco un esempio in C++:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We use `struct` so that everything is `public` by default</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Parabola <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// No need to create a constructor, the compiler will do it for us</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> x <span class="op">*</span> x <span class="op">+</span> b <span class="op">*</span> x <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  Parabola par1<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">};</span>  <span class="co">// x² + 2x + 3</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  Parabola par2<span class="op">{</span><span class="fl">2.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">};</span> <span class="co">// 2x² - 1</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ..</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Una funzionalità del genere è comoda, ma non funziona con la definizione <code>template</code> di <code>midpoint()</code>, perché per valutare <code>par1</code> nel punto <span class="math inline">x = 3</span> bisogna scrivere <code>par1.Eval(3.0)</code>, mentre <code>midpoint()</code> non si aspetta di invocare un metodo <code>Eval</code>: se le si passasse <code>par1</code>, per com’è fatta la versione <code>template</code> di <code>midpoint()</code> riscriverebbe la riga <code>accum += fn(x)</code> come <code>accum += par1(x)</code> anziché <code>accum += par1.Eval(x)</code>, e il compilatore darebbe errore.</p>
<p>Si può risolvere il problema trasformando <code>Parabola</code> in un <em>functore</em>, ossia in una classe che “finge” di essere una funzione. Questo è possibile facendo l’overloading di <code>operator()</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We use `struct` so that everything is `public` by default</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Parabola <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> a<span class="op">,</span> b<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">*</span> x <span class="op">*</span> x <span class="op">+</span> b <span class="op">*</span> x <span class="op">+</span> c<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This operator makes the class a “functor”</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Eval<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Nel nostro esempio, <code>operator()</code> non fa altro che invocare internamente <code>Eval</code>, ed è quindi del tutto equivalente. Ma ora si può usare qualsiasi oggetto <code>Parabola</code> come se fosse una funzione:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  Parabola par1<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">};</span>  <span class="co">// x² + 2x + 3</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  Parabola par2<span class="op">{</span><span class="fl">2.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">};</span> <span class="co">// 2x² - 1</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// par1 looks like a function, but it&#39;s a class!</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;par1 in x = 3 is </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> par1<span class="op">(</span><span class="fl">3.0</span><span class="op">));</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// The same for par2</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;par2 in x = 3 is </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> par2<span class="op">(</span><span class="fl">3.0</span><span class="op">));</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Con la definizione di <code>operator()</code>, gli oggetti <code>Parabola</code> possono essere passati alla nostra versione di <code>midpoint()</code> che usa i <code>template</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>Parabola par<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="fl">3.0</span><span class="op">};</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> midpoint<span class="op">(</span>par<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="dv">50</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Dal momento che <code>Parabola</code> è comunque una classe derivata da <code>FunzioneBase</code>, essa può essere passata anche a tutte quelle funzioni che avevate definito negli esercizi e che usano la programmazione ad oggetti.</p>
<h1 id="temaA">Tema 1 (stima di integrali)</h1>
<p>Questo è il link per aprire il testo: <a href="https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_1.pdf" class="uri">https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_1.pdf</a></p>
<p>Si tratta di un tema molto articolato, con ben sette punti, ma ciascuno di questi è abbastanza veloce da implementare.</p>
<h2 id="letturaTestoA">Lettura del testo</h2>
<p>Uno dei consigli più importanti forniti nella sezione <a href="index.html#esamescritto">Come prepararsi all’esame scritto</a> è quello di leggere il testo da cima a fondo prima di iniziare a scrivere del codice: è necessario infatti capire se ci sono più punti che possono essere svolti in modo simile, o delle peculiarità che richiedono di impostare il codice in un certo modo.</p>
<p>In questo primo tema mostrerò come si legge un tema in modo “evoluto”; potreste restarne spaventati, ma non temete! Nei temi successivi mostrerò una serie di tecniche operative che vi permetteranno di imparare a fare questo lavoro essenziale.</p>
<p>Vediamo quindi come fare per leggere i sette punti di questo tema in modo corretto.</p>
<blockquote>
<p>Si stimi il valore di questo integrale con il metodo del punto medio (“midpoint”). Sapendo che il valore vero dell’integrale è <span class="math inline">3e^2/16</span>, costruire una tabella o un grafico in cui si mostra l’andamento dell’errore per un numero di punti che va da 2 a 1024 in potenze di 2.</p>
</blockquote>
<p>Si dovrebbe quindi già capire qui che sarà necessario recuperare il codice dell’<a href="carminati-esercizi-07.html#esercizio-7.0">esercizio 7.0</a>, dove si è implementato il metodo del punto medio. Nella lezione di teoria si è discusso come stimare l’errore nel caso in cui non sia noto il valore esatto dell’integrale, ma qui siamo facilitati, perché il valore vero viene dato già nel testo: <span class="math inline">3e^2/16</span>. (C’era da aspettarselo: in un tema d’esame con ben sette domande, sarebbe molto strano trovare richieste complicate già al primo punto!)</p>
<p>Dovremo stampare “una tabella o un grafico”; è <em>sempre</em> buona cosa stampare la tabella, anche nel caso in cui producete il grafico. Ovviamente, già ci dobbiamo aspettare che l’errore diminuisca man mano che il numero di punti cresce.</p>
<p>Procediamo ora con la lettura del secondo punto:</p>
<blockquote>
<p>Assumendo che l’errore scali con una legge del tipo <span class="math inline">\varepsilon = k_1 h^{k_2}</span>, dove <span class="math inline">h</span> è la dimensione del passo di integrazione, stimare i valori dei coefficienti <span class="math inline">k_1</span> e <span class="math inline">k_2</span>.</p>
</blockquote>
<p>Leggendo questo punto, ci rendiamo conto che nel punto precedente sarà bene non limitarsi a stampare la tabella, ma fare anche il grafico: il testo infatti qui ci dice che l’andamento dell’errore, se plottato in scala logaritmica, deve seguire una retta della forma <span class="math inline">y = m x + q</span>, con <span class="math inline">y = \log\varepsilon</span>, <span class="math inline">x = \log h</span>, pendenza <span class="math inline">m = k_2</span> e intercetta <span class="math inline">q = \log k_1</span>.</p>
<p>(Questo può essere un buon momento per prendere un foglio di brutta e fare un paio di calcoli per ridurre espressioni come <span class="math inline">\varepsilon = k_1 h^{k_2}</span> e capire se si vorrà usare una scala lineare, o logaritmica sulle x, o sulle y, o come nel caso di questo esercizio specifico <strong>bilogaritmica</strong>…).</p>
<p>Passiamo al terzo punto:</p>
<blockquote>
<p>A partire dal metodo del punto medio si aggiunga un nuovo metodo di integrazione (“midright”) che invece di considerare il valore della funzione nel punto medio di un intervallo, la valuti nell’estremo di destra. Si stimi il valore del medesimo integrale con il nuovo metodo di integrazione. Come nel caso precedente sapendo che il valore vero dell’integrale è <span class="math inline">3e^2/16</span>, costruire una tabella o un grafico in cui si mostra l’andamento dell’errore per un numero di punti che va da 2 a 1024 in potenze di 2.</p>
</blockquote>
<p>Qui le cose si fanno interessanti… Dovremo quindi riprendere la nostra implementazione dell’algoritmo del punto medio, farne un copia-e-incolla e modificare questa copia in modo che anziché prendere il punto centrale prenda quello destro. (Sarebbe forse stato più appropriato chiamarlo “right-point” anziché “mid-right”, perché “mid” qui non c’entra, ma seguiamo il nome dato nel testo!)</p>
<p>Avremo quindi una nuova classe <code>MidRight</code>, derivata da <code>Integral</code> e modellata come la classe <code>MidPoint</code>, nel senso che il codice che implementa il metodo <code>MidRight::calculate()</code> sarà molto simile a <code>MidPoint::calculate()</code>, e differirà solo nel calcolo del valore in cui valutare l’integranda. Non abbiamo ancora iniziato a scrivere il codice (stiamo ancora leggendo il testo!), ma nella nostra mente potrebbe iniziare ad apparire il vago profilo di una classe fatta così:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MidRight <span class="op">:</span> <span class="kw">public</span> Integral <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> calculate<span class="op">(</span><span class="dt">int</span> nstep<span class="op">,</span> FunzioneBase <span class="op">&amp;</span>f<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Et cetera...</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Notiamo subito che questo punto #3 del tema d’esame è molto simile al punto #1: persino i valori da usare nella tabella sono identici! L’unica cosa per cui lo svolgimento differisce è il metodo di integrazione: “midpoint” al punto #1, “midright” al punto #3. Questa osservazione ci suggerisce quindi di implementare una funzione dedicata a questo compito e chiamarla due volte nel <code>main()</code>. Smpre continuando ad immaginare il codice che scriveremo, potremmo pensare di fare una cosa così:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> true_value<span class="op">{</span><span class="dv">3</span> <span class="op">*</span> exp<span class="op">(</span><span class="fl">2.0</span><span class="op">)</span> <span class="op">/</span> <span class="dv">16</span><span class="op">};</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> n<span class="op">{</span><span class="dv">2</span><span class="op">};</span> n <span class="op">&lt;=</span> <span class="dv">1024</span><span class="op">;</span> n <span class="op">*=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Usa `integral` per calcolare l&#39;integrale</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Confronta l&#39;integrale con il valore di `true_value`</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Stampa l&#39;errore a video</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>e poi ovviamente immaginiamo di usare questa ipotetica <code>calculate_errors()</code> nel <code>main()</code>, più o meno così:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Svolgimento punto 1:</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    MidPoint midpoint<span class="op">{};</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    calculate_errors<span class="op">(</span>midpoint<span class="op">);</span>  <span class="co">// Qui dico di integrare col midpoint</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Svolgimento punto 2:</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Svolgimento punto 3:</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    MidRight midright<span class="op">{};</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    calculate_errors<span class="op">(</span>midright<span class="op">);</span>  <span class="co">// Qui dico di integrare col midright</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Et cetera…</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Attenzione! Ripeto ancora una volta che non stiamo ancora scrivendo del codice, questi frammenti di C++ stanno ancora nella vostra testa, oppure ancora meglio sul vostro foglio di brutta! Non scriviamo ancora nulla perché non abbiamo ancora terminato di leggere il testo della prova d’esame, e non sappiamo se una funzione come <code>calculate_errors()</code> farà al caso nostro. E infatti, se leggiamo il punto 4, facciamo una scoperta interessante:</p>
<blockquote>
<p>Assumendo che l’errore scali con una legge del tipo <span class="math inline">\varepsilon = k_1 h^{k_2}</span>, dove <span class="math inline">h</span> è la dimensione del passo di integrazione, stimare i valori dei coefficienti <span class="math inline">k_1</span> e <span class="math inline">k_2</span>.</p>
</blockquote>
<p>Il punto #4 è esattamente identico al #2, parola per parola! Questo vuol dire che la nostra funzione <code>calculate_errors</code> che avevamo immaginato sopra andrebbe estesa in modo che non si limiti a stampare la tabella (punto #1 e punto #3), ma anche a calcolare i coefficienti <span class="math inline">k_1</span> e <span class="math inline">k_2</span> (punto #2 e punto #4).</p>
<p>Nella nostra testa (o nei nostri appunti), <code>calculate_errors</code> si trasforma quindi in qualcosa del genere</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> true_value<span class="op">{</span><span class="dv">3</span> <span class="op">*</span> exp<span class="op">(</span><span class="fl">2.0</span><span class="op">)</span> <span class="op">/</span> <span class="dv">16</span><span class="op">};</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Salviamo tutti i valori di h e gli errori in due vettori</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> step_size<span class="op">{};</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> error<span class="op">{};</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> n<span class="op">{</span><span class="dv">2</span><span class="op">};</span> n <span class="op">&lt;=</span> <span class="dv">1024</span><span class="op">;</span> n <span class="op">*=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> cur_h<span class="op">{(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">/</span> n<span class="op">};</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Usa `integral` per calcolare l&#39;integrale</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Confronta l&#39;integrale con il valore di `true_value`</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Stampa l&#39;errore a video</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Aggiunge il valore di `h` a `step_size` e l&#39;errore a `error`</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>    step_size<span class="op">.</span>push_back<span class="op">(</span>cur_h<span class="op">);</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>    error<span class="op">.</span>push_back<span class="op">(</span>error<span class="op">);</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ora eseguiamo una interpolazione sui valori che abbiamo salvato in</span></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `step_size` ed `error`</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Stampiamo i valori di k₁ e k₂</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Se finora abbiamo immaginato tutto il codice nella testa, ormai le cose da considerare stanno diventando decisamente troppe: meglio tirare fuori quel famoso foglio di brutta e iniziare davvero a scrivere… Anche perché ci siamo dimenticati di una cosa: il grafico! Abbiamo detto che è importante verificare che su scala bilogaritmica l’andamento dell’errore sia lineare!</p>
<p>È sempre bene creare i grafici in file PNG anziché mostrarli a video: potete navigare tra di essi più facilmente, se usate Replit è più veloce visualizzarli, e potete salvare copie di backup se state per fare modifiche al codice e volete confrontare i risultati prima o dopo. In tal caso, la funzione <code>calculate_errors</code> deve accettare un nuovo parametro, che contiene il nome del file PNG in cui sarà salvato il grafico:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span> string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ... (tutto identico a prima, fino alla fine) ...</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...ma prima di terminare creiamo il grafico</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  Gnuplot plt<span class="op">{};</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>redirect_to_png<span class="op">(</span>png_file_name<span class="op">);</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>plot<span class="op">(</span>step_size<span class="op">,</span> error<span class="op">);</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Step size h&quot;</span><span class="op">);</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;Error&quot;</span><span class="op">);</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>set_logscale<span class="op">(</span>Gnuplot<span class="op">::</span>AxisScale<span class="op">::</span>LOGXY<span class="op">);</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  plt<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Il fatto che il nome del file PNG sia passato come argomento ci permetterà di chiamare più volte nel <code>main()</code> la funzione <code>calculate_errors()</code>, senza che il file PNG venga sovrascritto a ogni chiamata. Questa è una tecnica che seguiremo in tutti i temi d’esame che svolgeremo in questa pagina.</p>
<p>Veniamo ora al punto 5:</p>
<blockquote>
<p>Stimare l’errore nel calcolo del medesimo integrale utilizzando il metodo della media con un numero di estrazioni pari a 16 ripetendo il calcolo un migliaio di volte.</p>
</blockquote>
<p>Bene, giunti a questo punto del compito dovremo quindi recuperare l’<a href="carminati-esercizi-10.html#esercizio-10.2">esercizio 10.2</a> sul calcolo dell’integrale col metodo della media. Non dovrebbero esserci complicazioni, si tratta semplicemente di implementare un ciclo <code>for</code> e poi calcolare l’errore: possiamo usare la funzione per calcolare la deviazione standard (o la varianza, ma in questo caso dovremo poi estrarre la radice quadrata) che avevamo implementato nell’<a href="carminati-esercizi-03.html#esercizio-3.1">esercizio 3.1</a>.</p>
<blockquote>
<p>Quanti punti sarebbero necessari per ottenere con il metodo della media la stessa precisione che si ottiene con il metodo del “midpoint” tradizionale a 16 punti?</p>
</blockquote>
<p>Qui si vede se gli studenti hanno studiato o no la teoria: com’è legato l’errore nel metodo della media al numero <span class="math inline">N</span> dei punti? Se si conosce la formula, basta fare un paio di calcoli su un foglio di brutta per trovare la formula matematica che dà la soluzione e implementarla nel proprio codice C++.</p>
<p>C’è però un piccolo dettaglio che non dobbiamo farci sfuggire. Per fare questo calcolo, ci occorre che il programma “ricordi” l’errore associato al metodo del mid-point che aveva trovato per il caso <span class="math inline">N = 16</span> nello svolgimento del punto #1.</p>
<p>Ci sono vari modi per fare questo:</p>
<ol>
<li><p>Il più facile è quello di eseguire il nostro programma una volta che i punti #1 e #2 sono implementati e corretti, annotarsi su un foglio l’errore calcolato nel caso <span class="math inline">N = 16</span> passaggi, e poi inserire brutalmente questo numero nella sezione del codice C++ che svolge questo punto #6.</p>
<p>Questo procedimento però è orribile! Se, una volta implementato il codice, ci accorgessimo prima di consegnare che c’era un errore nello svolgimento del punto #1 e riuscissimo a correggerlo, rischieremmo di dimenticarci di aggiornare il valore corrispondente qui!</p></li>
<li><p>Sarebbe allora meglio che la funzione <code>calculate_errors()</code> non ritorni un tipo <code>void</code>, ma proprio l’errore associato al caso <span class="math inline">N = 16</span>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Ho cambiato il tipo di ritorno da `void` a `double`</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span> string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> error_to_return<span class="op">{};</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> n <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> n <span class="op">&lt;=</span> <span class="dv">1024</span><span class="op">;</span> n <span class="op">*=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calcolo l&#39;errore...</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...ed ora lo salvo</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>n <span class="op">==</span> <span class="dv">16</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>            error_to_return <span class="op">=</span> cur_error<span class="op">;</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Creo e salvo il grafico</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Restituisco l&#39;errore associato al valore N=16</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> error_to_return<span class="op">;</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Nel <code>main()</code> quindi salverei l’errore restituito per lo svolgimento del punto #1 e lo userei poi quando è il tempo di risolvere il punto #6. (Se uno è elegante, può passare il valore <code>16</code> come parametro aggiuntivo di <code>calculate_errors()</code>).</p></li>
<li><p>La soluzione più consigliabile però è quella di far restituire a <code>calculate_errors()</code> l’intera tabella calcolata. È vero che nel punto #6 ci serve solo l’errore per <span class="math inline">N = 16</span>, ma avere a disposizione tutta la tabella ci può permettere rapidamente di usare dei <code>print</code> per fare debug nel <code>main()</code>, nel caso in cui il risultato del punto #6 ci sembrasse strano.</p>
<p>Proprio nell’ottica di aiutarci a fare debug, potremmo restituire queste quantità:</p>
<ol>
<li>I valori di <span class="math inline">N</span>;</li>
<li>I valori di <span class="math inline">h</span>;</li>
<li>I valori degli integrali calcolati;</li>
<li>Gli errori;</li>
<li>I valori di <span class="math inline">k_1</span> e <span class="math inline">k_2</span> nella formula dell’errore interpolato.</li>
</ol>
<p>Vorremmo restituire tutti questi valori alla fine della funzione <code>calculate_errors()</code>, ma c’è un problema: il C++ permette di restituire solo <em>un</em> valore!</p>
<p>La classica soluzione è quella di implementare una <code>struct</code> (vedi il <a href="#uso-di-struct">suggerimento</a>):</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ErrorTable <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> num_of_steps<span class="op">{};</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> step_size<span class="op">{};</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> value<span class="op">{};</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> error<span class="op">{};</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> k1<span class="op">{};</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> k2<span class="op">{};</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>e usare questa definizione per <code>calculate_errors</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>ErrorTable calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>                            string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    ErrorTable result<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fai i calcoli e riempi la variabile `result`</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<p>In questo modo potremo poi nel <code>main()</code> recuperare l’errore per il caso <span class="math inline">N = 16</span> facilmente.</p>
<p>Sarebbe anche meglio racchiudere l’implementazione del punto #5 in una funzione che accetti il numero <code>N</code> come input, in modo da poterla poi invocare per il punto #6 con il nuovo numero di punti e verificare così il risultato. Annotiamo quindi sul foglio di carta che dovremo implementare una funzione con questo prototipo:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> run_integral_mc_mean<span class="op">(</span><span class="dt">int</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>La funzione dovrà ovviamente restituire la deviazione standard dei 1000 campioni, ossia l’errore associato alla stima dell’integrale, in modo da poter implementare il punto #6 sulla base del risultato del punto #5.</p>
<blockquote>
<p>Si consideri ora il seguente integrale: [nuovo integrale]. Si provi a calcolarne il valore utilizzando uno dei due metodi (“midpoint” o “midright”) indicati sopra: quale usereste? Quanto vale il coefficiente <span class="math inline">k_2</span> in questo caso ?</p>
</blockquote>
<p>Di solito l’ultimo punto è “per la lode”, e richiede un po’ di lavoro in più. Qui dobbiamo abbandonare l’integrale che abbiamo usato nei sei punti precedenti e usarne uno nuovo, quindi si richiedono alcuni accorgimenti:</p>
<ol>
<li><p>Se abbiamo definito il valore vero del primo integrale (<span class="math inline">3e^2/16</span>) in una costante chiamata <code>true_value</code>, sarebbe bene rinominare quella costante <code>true_value1</code>, in modo da poter poi definire una nuova costante <code>true_value2</code> anche per questo secondo integrale. (Il testo non dice quanto vale, ma è facile calcolarlo).</p></li>
<li><p>La nostra funzione <code>calculate_errors()</code> accettava come unico parametro la classe che implementa il metodo di integrazione, perché a seconda del punto a cui stiamo rispondendo si vuole passare un’istanza della classe <code>MidPoint</code> o della classe <code>MidRight</code>. Quella funzione fa al caso nostro anche per il punto #7, ma dobbiamo modificarla in modo che anche la funzione da integrare sia passata come argomento:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Passo come argomenti sia l&#39;algoritmo di integrazione che l&#39;integranda</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>ErrorTable</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">const</span> FunzioneBase <span class="op">&amp;</span> fn<span class="op">,</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>                 string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p>Pensandoci meglio, come fa <code>calculate_errors</code> a calcolare l’errore, se il valore vero dell’integrale è diverso a seconda dell’integrale? Dovremmo passare anche il valore vero a <code>calculate_errors</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Passo sia l&#39;integrale che la funzione da integrare, che il valore atteso!</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>ErrorTable</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>                 <span class="at">const</span> FunzioneBase <span class="op">&amp;</span> fn<span class="op">,</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">double</span> true_value<span class="op">,</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>                 string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<p>Phew! Abbiamo terminato la lettura del testo, e ci siamo fatti un’idea del lavoro richiesto. Possiamo ora passare all’implementazione.</p>
<h2 id="temaApuntoA">Implementazione del punto 1</h2>
<p>Iniziamo col definire una serie di costanti che corrispondono ai parametri che compaiono nel testo:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numbers&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Costante di Nepero</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> e<span class="op">{</span>numbers<span class="op">::</span>e<span class="op">};</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Estremi di integrazione</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> a<span class="op">{</span><span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> b<span class="op">{</span>exp<span class="op">(</span><span class="fl">0.5</span><span class="op">)};</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Valore vero del primo integrale</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> true_value1<span class="op">{</span><span class="dv">3</span> <span class="op">*</span> exp<span class="op">(</span><span class="fl">2.0</span><span class="op">)</span> <span class="op">/</span> <span class="dv">16</span><span class="op">};</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Valore vero del secondo integrale; l&#39;integranda può essere riscritta</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="co">// tramite un cambio di variabile come 1/√(1 - y²), che è la derivata</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="co">// di arcsin(y). Se non ci arrivate, potete usare Wolfram Alpha da browser</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> true_value2<span class="op">{</span>numbers<span class="op">::</span>pi <span class="op">/</span> <span class="dv">2</span><span class="op">};</span></span></code></pre></div>
<p>Nel caso in cui non sappiate calcolare il valore del secondo integrale, potete usare il sito <a href="https://www.wolframalpha.com/">WolframAlpha</a>:</p>
<p><img src="images/exam1-wolfram-alpha-integral2.png" /></p>
<p>Passiamo ora ad implementare la funzione integranda. Se usiamo l’approccio di derivare una classe da <a href="carminati-esercizi-06.html#esercizio-6.1"><code>FunzioneBase</code></a>, la nostra sarà fatta così:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Funzione1 <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">double</span> x_squared<span class="op">{</span>x <span class="op">*</span> x<span class="op">};</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x_squared <span class="op">*</span> x <span class="op">*</span> log<span class="op">(</span>sqrt<span class="op">(</span>e <span class="op">+</span> x_squared<span class="op">));</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Un errore che compiono spesso gli studenti è quello di non verificare che le funzioni date nel testo siano implementate bene in C++. Si tratta di funzioni a volte complesse, dove è facile chiudere la parentesi nel posto sbagliato. Implementiamo alcuni test per essere certi che <code>Funzione1</code> operi come deve:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> are_close<span class="op">(</span><span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">double</span> eps <span class="op">=</span> <span class="fl">1.0e-7</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> abs<span class="op">(</span>a <span class="op">-</span> b<span class="op">)</span> <span class="op">&lt;</span> eps<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_code<span class="op">()</span> <span class="op">{</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  Funzione1 fun1<span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// I valori attesi sono calcolabili a mano</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>fun1<span class="op">.</span>Eval<span class="op">(</span><span class="fl">0.0</span><span class="op">),</span> <span class="fl">0.0</span><span class="op">));</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>fun1<span class="op">.</span>Eval<span class="op">(</span><span class="fl">1.0</span><span class="op">),</span> <span class="fl">0.5</span> <span class="op">*</span> log<span class="op">(</span>e <span class="op">+</span> <span class="dv">1</span><span class="op">)));</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>fun1<span class="op">.</span>Eval<span class="op">(</span><span class="fl">2.0</span><span class="op">),</span> <span class="fl">8.0</span> <span class="op">*</span> log<span class="op">(</span>sqrt<span class="op">(</span>e <span class="op">+</span> <span class="fl">4.0</span><span class="op">))));</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>  cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;All the tests passed. Hurrah!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Veniamo ora al “cuore” del punto #1. Riguardando i nostri appunti, vediamo che abbiamo stabilito di implementare sia il punto #1 che il punto #2 in una funzione <code>calculate_errors()</code>. Seguiamo quindi il prototipo che avevamo stabilito per implementarla, ricordando che dovremo riempire una variabile di tipo <code>ErrorTable</code> in modo da poterla restituire ed impiegarla nel <code>main()</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>ErrorTable</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">const</span> FunzioneBase <span class="op">&amp;</span> fn<span class="op">,</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">double</span> true_value<span class="op">,</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>                 string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>  ErrorTable results<span class="op">;</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> n <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> n <span class="op">&lt;=</span> <span class="dv">1024</span><span class="op">;</span> n <span class="op">*=</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    results<span class="op">.</span>num_of_steps<span class="op">.</span>push_back<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> h<span class="op">{(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">/</span> n<span class="op">};</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>    results<span class="op">.</span>step_size<span class="op">.</span>push_back<span class="op">(</span>h<span class="op">);</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> cur_value<span class="op">{</span>integral<span class="op">.</span>integrate<span class="op">(</span>a<span class="op">,</span> b<span class="op">,</span> n<span class="op">,</span> fn<span class="op">)};</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>    results<span class="op">.</span>value<span class="op">.</span>push_back<span class="op">(</span>cur_value<span class="op">);</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> cur_error<span class="op">{</span>abs<span class="op">(</span>cur_value <span class="op">-</span> true_value<span class="op">)};</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>    results<span class="op">.</span>error<span class="op">.</span>push_back<span class="op">(</span>cur_error<span class="op">);</span></span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-21"><a href="#cb41-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Vedi più sotto</span></span>
<span id="cb41-22"><a href="#cb41-22" aria-hidden="true" tabindex="-1"></a>  results<span class="op">.</span>print_table<span class="op">();</span></span>
<span id="cb41-23"><a href="#cb41-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-24"><a href="#cb41-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> results<span class="op">;</span></span>
<span id="cb41-25"><a href="#cb41-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Per stampare i valori, avremmo potuto inserire direttamente il codice in <code>calculate_errors</code>; però questa è effettivamente una funzionalità che appartiene alla classe <code>ErrorTable</code>, così scegliamo di implementarla come metodo (che, essendo la classe stata definita tramite la parola chiave <code>struct</code>, è di default pubblico e quindi invocabile da chichessia):</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ErrorTable <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> num_of_steps<span class="op">{};</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> step_size<span class="op">{};</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> value<span class="op">{};</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> error<span class="op">{};</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> k1<span class="op">{};</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> k2<span class="op">{};</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">/// Output the table with the errors to `cout`</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> print_error_table<span class="op">()</span> <span class="op">{</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Error table:</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{:&gt;6s}\t{:&gt;20s}\t{:&gt;20s}\t{:&gt;20s}\t{:&gt;20s}</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;N&quot;</span><span class="op">,</span> <span class="st">&quot;h&quot;</span><span class="op">,</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>                 <span class="st">&quot;Value&quot;</span><span class="op">,</span> <span class="st">&quot;Error&quot;</span><span class="op">,</span> <span class="st">&quot;Estimated error&quot;</span><span class="op">);</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> ssize<span class="op">(</span>step_size<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>      <span class="dt">double</span> estimated_error<span class="op">{</span>interpolated_error<span class="op">(</span>step_size<span class="op">[</span>i<span class="op">])};</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>      fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{:6d}\t{:20.7e}\t{:20.7e}\t{:20.7e}\t{:20.7e}</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>                   num_of_steps<span class="op">.</span>at<span class="op">(</span>i<span class="op">),</span> step_size<span class="op">.</span>at<span class="op">(</span>i<span class="op">),</span> value<span class="op">.</span>at<span class="op">(</span>i<span class="op">),</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>                   error<span class="op">.</span>at<span class="op">(</span>i<span class="op">),</span> estimated_error<span class="op">);</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Ovviamente il codice fa uso della libreria <a href="index.html#fmtinstall">fmtlib</a> per stampare la tabella in un formato gradevole.</p>
<p>Dobbiamo ora implementare il <code>main</code>, che è banale:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Chiamiamo i test che verificano il codice che abbiamo scritto</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  test_code<span class="op">();</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Stampiamo il valore vero dell&#39;integrale, in modo da tenerlo sott&#39;occhio</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>print<span class="op">(</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;True value of the integral between a=</span><span class="sc">{:.3f}</span><span class="st"> and b=</span><span class="sc">{:.3f}</span><span class="st">: </span><span class="sc">{:.5f}\n\n</span><span class="st">&quot;</span><span class="op">,</span> a<span class="op">,</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>      b<span class="op">,</span> true_value1<span class="op">);</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #1</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>  Midpoint midpoint<span class="op">;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>  Function1 fun1<span class="op">;</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Salviamo il risultato in `midpoint_results`, perché sappiamo che</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// poi dovremo usarlo nello svolgimento del punto #6</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>  ErrorTableResults midpoint_results<span class="op">{</span>calculate_errors<span class="op">(</span>midpoint<span class="op">,</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>                                                      fun1<span class="op">,</span> true_value1<span class="op">,</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>                                                      <span class="st">&quot;point1.png&quot;</span><span class="op">)};</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Et voilà, se compiliamo il codice, ecco l’output:</p>
<pre><code>All the tests passed. Hurrah!
True value of the integral between a=0.000 and b=1.649: 1.38545

# Point #1

Error table:
     N                   h               Value               Error     Estimated error
     2       8.2436064e-01       1.1577259e+00       2.2772215e-01       2.2772215e-01
     4       4.1218032e-01       1.3273320e+00       5.8116025e-02       5.7101881e-02
     8       2.0609016e-01       1.3708484e+00       1.4599573e-02       1.4318435e-02
    16       1.0304508e-01       1.3817938e+00       3.6542570e-03       3.5903821e-03
    32       5.1522540e-02       1.3845342e+00       9.1383628e-04       9.0029700e-04
    64       2.5761270e-02       1.3852195e+00       2.2847606e-04       2.2575165e-04
   128       1.2880635e-02       1.3853909e+00       5.7120077e-05       5.6607773e-05
   256       6.4403175e-03       1.3854337e+00       1.4280086e-05       1.4194536e-05
   512       3.2201587e-03       1.3854444e+00       3.5700255e-06       3.5593142e-06
  1024       1.6100794e-03       1.3854471e+00       8.9250664e-07       8.9250664e-07</code></pre>
<p>ed ecco il grafico:</p>
<p><img src="images/exam1-point1.png" /></p>
<p>L’andamento su scala bilogaritmica è effettivamente lineare, e l’errore decrescere man mano che decresce il passo <span class="math inline">h</span>: ottimo!</p>
<h2 id="temaApuntoB">Implementazione del punto 2</h2>
<p>Per implementare il punto #2, nei nostri appunti avevamo scritto di modificare la funzione <code>calculate_errors</code>, che ora dovrà implementare alcune istruzioni aggiuntive dopo aver calcolato la tabella, per inizializzare le variabili <code>k1</code> e <code>k2</code> della classe <code>ErrorTable</code>:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>ErrorTable</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>calculate_errors<span class="op">(</span><span class="at">const</span> Integral <span class="op">&amp;</span> integral<span class="op">,</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                 <span class="at">const</span> FunzioneBase <span class="op">&amp;</span> fn<span class="op">,</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">double</span> true_value<span class="op">,</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>                 string png_file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Tutto il ciclo `for` resta identico</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Calcola k1 e k2, la implementeremo tra un attimo</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>  results<span class="op">.</span>calculate_k1_and_k2<span class="op">();</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>  results<span class="op">.</span>print_error_table<span class="op">();</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;k₁ = </span><span class="sc">{:.2f}</span><span class="st">, k₂ = </span><span class="sc">{:.2f}</span><span class="st">&quot;</span><span class="op">,</span> results<span class="op">.</span>k1<span class="op">,</span> results<span class="op">.</span>k2<span class="op">);</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> results<span class="op">;</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Per calcolare <span class="math inline">k_1</span> e <span class="math inline">k_2</span>, dobbiamo ricordare che il testo dice di interpolare il passo <span class="math inline">h</span> e l’errore <span class="math inline">\varepsilon</span> con la formula <span class="math inline">\varepsilon = k_1 \cdot h^{k_2}</span>. Possiamo interpolare tra il primo punto (che chiamiamo <span class="math inline">a</span>) e l’ultimo punto (che chiamiamo <span class="math inline">b</span>), considerando che il grafico rivela un andamento approssimativamente lineare su scala logaritmica: <span class="math display">
\begin{cases}
\varepsilon_a = k_1 \cdot h_a^{k_2},\\
\varepsilon_b = k_1 \cdot h_b^{k_2},\\
\end{cases}
</span> e facendone il rapporto per semplificare <span class="math inline">k_1</span> si ottiene <span class="math display">
\frac{\varepsilon_a}{\varepsilon_b} = \left(\frac{h_a}{h_b}\right)^{k_2}\quad\Rightarrow\quad k_2 = \frac{\log\bigl(\varepsilon_b / \varepsilon_a\bigr)}{\log\bigl(h_b / h_a\bigr)}.\\
</span> da cui è ora facile ricavare <span class="math inline">k_1</span>: <span class="math display">
k_1 = \frac{\varepsilon_a}{h_a^{k_2}}.
</span></p>
<p>Implementiamo quindi il metodo <code>ErrorTable.calculate_k1_and_k2()</code>:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ErrorTable <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> calculate_k1_and_k2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Usiamo il primo e l&#39;ultimo valore della tabella per calcolare</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// un&#39;interpolazione lineare sulla scala bilogaritmica</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    k2 <span class="op">=</span> log<span class="op">(</span>error<span class="op">.</span>back<span class="op">()</span> <span class="op">/</span> error<span class="op">.</span>front<span class="op">())</span> <span class="op">/</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>         log<span class="op">(</span>step_size<span class="op">.</span>back<span class="op">()</span> <span class="op">/</span> step_size<span class="op">.</span>front<span class="op">());</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    k1 <span class="op">=</span> error<span class="op">.</span>front<span class="op">()</span> <span class="op">/</span> pow<span class="op">(</span>step_size<span class="op">.</span>front<span class="op">(),</span> k2<span class="op">);</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Abbiamo usato qui i comodi metodi <code>front()</code> e <code>back()</code> della classe <code>std::vector</code>, che restituiscono il valore del primo e dell’ultimo elemento del vettore.</p>
<p>L’output che otteniamo appena sotto la tabella è il seguente:</p>
<pre><code>k₁ = 0.33, k₂ = 2.00</code></pre>
<p>che ci rassicura: <span class="math inline">k_2</span> è l’esponente del termine <span class="math inline">h</span>, e vediamo che il metodo del mid-point segue una legge <span class="math inline">\varepsilon \propto h^2</span>, che è quello che ci dovevamo aspettare, visto che conosciamo molto bene la teoria! 😉</p>
<h2 id="temaApuntoCD">Implementazione dei punti 3 e 4</h2>
<p>È necessario ora implementare il cosiddetto metodo del “mid-right”. Facciamo un copia-e-incolla della definizione della classe <code>MidPoint</code> dentro il nostro file <code>main.cpp</code>: è inutile creare un file <code>midright.h</code> e un file <code>midright.cpp</code>, e poi stare a impazzire aggiornando il <code>Makefile</code>…</p>
<p>Ricordate che nell’<a href="carminati-esercizi-07.html#esercizio-7.0">esercizio 7.0</a> avevamo implementato la classe <code>Integral</code> in modo che fosse da sovrascrivere il metodo privato <code>calculate</code>, e che potevamo assumere che gli estremi di integrazione <span class="math inline">a</span> e <span class="math inline">b</span> fossero già ordinati: <span class="math inline">a &lt; b</span>. Questo ci torna utile: ora non dobbiamo fare alcun controllo su di essi né ricordarci di cambiare il segno all’integrale se necessario.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MidRight <span class="op">:</span> <span class="kw">public</span> Integral <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> calculate<span class="op">(</span><span class="dt">int</span> nstep<span class="op">,</span> FunzioneBase <span class="op">&amp;</span>f<span class="op">)</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> accum<span class="op">{};</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> nstep<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>      accum <span class="op">+=</span> f<span class="op">.</span>Eval<span class="op">(</span>a <span class="op">+</span> <span class="op">(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">/</span> n<span class="op">);</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> accum <span class="op">*</span> <span class="op">(</span>b <span class="op">-</span> a<span class="op">)</span> <span class="op">/</span> n<span class="op">;</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Dobbiamo però sincerarci che il metodo sia stato implementato correttamente. Abbiamo ancora la classe <code>Seno</code> implementata nell’<a href="carminati-esercizi-07.html#esercizio-7.0">esercizio 7.0</a>, così copiamola nel <code>main.cpp</code> e aggiungiamo un paio di test alla funzione <code>test_code()</code> che avevamo implementato prima. Col metodo del mid-right usando <span class="math inline">N = 1</span> si restituisce il valore della funzione sull’estremo destro <span class="math inline">x = b</span>, quindi <span class="math display">
\int_0^1 \sin x\,\mathrm{d}x \stackrel{N = 1}{\approx} \sin1.
</span> Con <span class="math inline">N = 2</span>, si restituisce invece la media tra il valore nella posizione centrale <span class="math inline">x = (a + b)/2</span> e l’estremo <span class="math inline">x = b</span>: <span class="math display">
\int_0^1 \sin x\,\mathrm{d}x \stackrel{N = 2}{\approx} \frac{\sin\frac12 + \sin1}2.
</span> Implementiamo quindi entrambi questi test, per essere sicuri che la nostra implementazione di <code>MidRight</code> funzioni bene:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_code<span class="op">()</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  Seno seno<span class="op">{};</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  MidRight midright<span class="op">{};</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>midright<span class="op">.</span>integrate<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> seno<span class="op">),</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>                   sin<span class="op">(</span><span class="fl">1.0</span><span class="op">));</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>midright<span class="op">.</span>integrate<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> seno<span class="op">),</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>                   <span class="op">(</span>sin<span class="op">(</span><span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> sin<span class="op">(</span><span class="fl">1.0</span><span class="op">))</span> <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>  cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;All the tests passed. Hurrah!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Una volta implementato <code>MidRight</code>, l’implementazione dei punti #3 e #4 è automatica per come avevamo implementato <code>calculate_errors()</code>: basta invocarlo una seconda volta nel <code>main()</code> passando però una istanza di <code>MidRight</code> anziché <code>MidPoint</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  test_code<span class="op">();</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Il codice per i punti #1 e #2 resta ovviamente uguale</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Points 3 and 4</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>  MidRight midright<span class="op">;</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>  calculate_errors<span class="op">(</span>midright<span class="op">,</span> fun1<span class="op">,</span> true_value1<span class="op">,</span> <span class="st">&quot;point3.png&quot;</span><span class="op">)};</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notate che a differenza del punto #1 qui non salviamo il risultato di <code>calculate_errors</code>, perché non ci interessa. L’output è il seguente:</p>
<pre><code># Points 3 and 4

Error table:

     N                h               Value               Error     Estimated error
     2    8.2436064e-01       3.4101235e+00       2.0246755e+00       2.0246755e+00
     4    4.1218032e-01       2.2839247e+00       8.9847667e-01       9.8376464e-01
     8    2.0609016e-01       1.8056283e+00       4.2018032e-01       4.7799900e-01
    16    1.0304508e-01       1.5882384e+00       2.0279037e-01       2.3225377e-01
    32    5.1522540e-02       1.4850161e+00       9.9568059e-02       1.1284922e-01
    64    2.5761270e-02       1.4347751e+00       4.9327111e-02       5.4832031e-02
   128    1.2880635e-02       1.4099973e+00       2.4549318e-02       2.6642202e-02
   256    6.4403175e-03       1.3976941e+00       1.2246099e-02       1.2945115e-02
   512    3.2201587e-03       1.3915639e+00       6.1159093e-03       6.2898701e-03
  1024    1.6100794e-03       1.3885042e+00       3.0561697e-03       3.0561697e-03


k₁ = 2.48, k₂ = 1.04</code></pre>
<p>e questo è il grafico:</p>
<p><img src="images/exam1-point3.png" /></p>
<p>Notate che ora l’errore segue la legge <span class="math inline">\varepsilon \propto h</span> (l’esponente di <span class="math inline">h</span> è 1): il mid-right non funziona così bene come il mid-point.</p>
<h2 id="temaApuntoE">Implementazione del punto 5</h2>
<p>Per svolgere il punto #5 dobbiamo recuperare l’algoritmo per il calcolo dell’integrale col metodo della media dall’<a href="carminati-esercizi-10.html#esercizio-10.2">esercizio 10.2</a>, e la funzione <code>stddev</code> per calcolare la deviazione standard dall’<a href="carminati-esercizi-03.html#esercizio-3.1">esercizio 3.1</a>.</p>
<p>Come avevamo stabilito quando abbiamo letto il testo dei punti #5 e #6, implementiamo il codice che risolve il punto #5 in una funzione <code>run_integral_mc_mean</code>:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> run_integral_mc_mean<span class="op">(</span><span class="dt">int</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  IntegraleMedia media<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> mc_samples<span class="op">(</span><span class="dv">1000</span><span class="op">);</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> ssize<span class="op">(</span>mc_samples<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    mc_samples<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> media<span class="op">.</span>Integra<span class="op">(</span>fun1<span class="op">,</span> a<span class="op">,</span> b<span class="op">,</span> N<span class="op">,</span> <span class="fl">0.0</span><span class="op">);</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> error_mc<span class="op">{</span>stddev<span class="op">(</span>mc_samples<span class="op">)};</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Estimate of the integral using the mean method with N=</span><span class="sc">{}</span><span class="st"> points: &quot;</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>             <span class="st">&quot;</span><span class="sc">{:.5f}</span><span class="st"> ± </span><span class="sc">{:.5f}\n\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>             N<span class="op">,</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>             mc_samples<span class="op">.</span>front<span class="op">(),</span> <span class="co">// Let&#39;s take the first sample</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>             error_mc<span class="op">);</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> error_mc<span class="op">;</span></span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Se volete potete produrre anche un istogramma di <code>mc_samples</code>, per verificare la bontà dei risultati. Ci sono alcune cose a cui stare attenti:</p>
<ul>
<li><p>Non confondete il numero di campioni del metodo della media (<span class="math inline">N = 16</span>) con il numero di estrazioni Monte Carlo (1000)!</p></li>
<li><p>Anche se non è richiesto dal testo del problema, è bene stampare il valore stimato dell’integrale e non solo il suo errore: se tutto è implementato come si deve, dovremmo ritrovare un valore che non si discosta molto dal valore vero (<span class="math inline">3e^2 / 16 \approx 1.385</span>).</p></li>
<li><p>Attenzione al valore che attribuite all’integrale! Anche se avete 1000 stime dell’integrale in <code>mc_mean</code>, non potete calcolarne la media e dire che quel valore è affetto dall’errore restituito dalla chiamata a <code>stddev</code>. In altre parole, questo codice è <strong>errato</strong>:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Estimate of the integral using the mean method with N=</span><span class="sc">{}</span><span class="st"> points: &quot;</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;</span><span class="sc">{:.5f}</span><span class="st"> ± </span><span class="sc">{:.5f}\n\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>           N<span class="op">,</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>           mean<span class="op">(</span>mc_samples<span class="op">),</span> <span class="co">// WRONG WRONG WRONG!</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>           error_mc<span class="op">);</span></span></code></pre></div>
<p>perché l’errore associato al valore medio dei valori in <code>mc_samples</code> non è la deviazione standard <span class="math inline">\sigma</span> restituita da <code>stddev</code>, bensì l’errore della media <span class="math inline">\sigma / \sqrt{N}</span>. Questo non è però quanto richiede il testo del tema d’esame, che parla esplicitamente di “errore nel calcolo […] dell’integrale […] con un numero di estrazioni pari a 16”. Se mediate insieme 1000 valori, non è più l’errore del caso <span class="math inline">N = 16</span>, ma corrisponde a un caso in cui <span class="math inline">N = 16 \times 1000</span>.</p>
<p>Nel nostro codice stampiamo come valore di riferimento il primo dei 1000 calcolati (<code>mc_samples.front()</code>), ma ne avremmo potuto scegliere un qualsiasi elemento del vettore e sarebbe andato bene ugualmente.</p></li>
</ul>
<p>Nel <code>main()</code> eseguiamo <code>run_integral_mc_mean()</code> salvando il risultato in una variabile <code>error_mc</code>: ci servirà poi per implementare il punto #6:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> N<span class="op">{</span><span class="dv">16</span><span class="op">};</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> error_mc<span class="op">{</span>run_integral_mc_mean<span class="op">(</span>N<span class="op">)};</span></span></code></pre></div>
<p>L’output prodotto è il seguente:</p>
<pre><code># Point #5

Estimate of the integral using the mean method with N=16 points: 1.08628 ± 0.41611</code></pre>
<p>che è confortante, perché è compatibile con il valore vero dell’integrale (1.385) entro la barra d’errore.</p>
<h2 id="temaApuntoF">Implementazione del punto 6</h2>
<p>Per svolgere il punto #6 dobbiamo recuperare l’errore che avevamo calcolato nel punto #1, e che è stato salvato all’interno della variabile <code>midpoint_results</code> nel <code>main</code>. La variabile contiene l’intera tabella degli errori, ma a noi serve solo quello che corrisponde a <span class="math inline">N = 16</span>. Potremmo scrivere una funzione che cerca nella tabella qual è l’indice <code>k</code> che corrisponde al caso <code>midpoint_results.num_of_steps[k] == 16</code>, ma è più rapido guardare sul video qual è la riga corrispondente nell’output del nostro programma (la terza) e inserire questo valore direttamente nel codice, inserendo un <code>assert</code> per sicurezza:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> row_index<span class="op">{</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>midpoint_results<span class="op">.</span>num_of_steps<span class="op">[</span>row_index<span class="op">]</span> <span class="op">==</span> <span class="dv">16</span><span class="op">);</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Dobbiamo fare in modo che il metodo della media raggiunga questo errore</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> target_error<span class="op">{</span>midpoint_results<span class="op">.</span>error<span class="op">[</span>row_index<span class="op">]};</span></span></code></pre></div>
<p>In questo modo, se prima di consegnare lo scritto ci accorgeremo di aver sbagliato a produrre la tabella e la riga corrispondente non sarà più la numero 3, il codice ci avviserà del problema. Ricordate sempre che è meglio essere prudenti, e spendere un po’ di tempo per implementare questi <code>assert()</code> può evitare di avere errori la cui correzione richiede molto tempo!</p>
<p>Sapendo che l’errore nel metodo della media varia come <span class="math inline">\varepsilon(N) = \sigma / \sqrt{N}</span>, manipolando l’espressione otteniamo che <span class="math display">
N_{\text{target}} = N \cdot \left(\frac{\varepsilon(N)}{\epsilon_{\text{target}}}\right)
</span> che si traduce immediatamente nel seguente codice C++:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> new_N<span class="op">{</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>N <span class="op">*</span> pow<span class="op">(</span>error_mc <span class="op">/</span> target_error<span class="op">,</span> <span class="fl">2.0</span><span class="op">))};</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Number of points required for the mean method to achieve an &quot;</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;error of </span><span class="sc">{:.3e}</span><span class="st">: </span><span class="sc">{}\n\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>           target_error<span class="op">,</span> new_N<span class="op">);</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Esegui di nuovo il Monte Carlo per verificare che l&#39;errore calcolato sia corretto</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>run_integral_mc_mean<span class="op">(</span>new_N<span class="op">);</span></span></code></pre></div>
<p>Questo è l’output:</p>
<pre><code># Point #6

Number of points required for the mean method to achieve an error of 3.654e-03: 207466

Estimate of the integral using the mean method with N=207466 points: 1.38456 ± 0.00366</code></pre>
<p>L’errore prodotto è compatibile con quello atteso: <code>0.00366</code> rispetto a <code>3.654e-03</code>, quindi lo svolgimento è corretto.</p>
<h2 id="temaApuntoG">Implementazione del punto 7</h2>
<p>Resta l’ultimo punto, quello “per la lode”, che però non richiede molto sforzo per essere implementato. È sufficiente ereditare una nuova classe da <code>FunzioneBase</code> e implementare l’integranda:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Funzione2 <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">1.0</span> <span class="op">/</span> sqrt<span class="op">(</span><span class="fl">4.0</span> <span class="op">-</span> x <span class="op">*</span> x<span class="op">);</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Aggiungiamo per sicurezza un paio di test in <code>test_code()</code>:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_code<span class="op">()</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// I test per `Funzione1` restano invariati</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>  Funzione2 fun2</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>fun2<span class="op">.</span>Eval<span class="op">(</span><span class="fl">0.0</span><span class="op">),</span> <span class="fl">0.5</span><span class="op">));</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>fun2<span class="op">.</span>Eval<span class="op">(</span><span class="fl">1.0</span><span class="op">),</span> <span class="fl">1.0</span> <span class="op">/</span> sqrt<span class="op">(</span><span class="fl">3.0</span><span class="op">)));</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>isinf<span class="op">(</span>fun2<span class="op">.</span>Eval<span class="op">(</span><span class="fl">2.0</span><span class="op">)));</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// I test per MidRight restano invariati</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
<p>Notate che verifichiamo che in <span class="math inline">x = 2</span> la funzione sia uguale a <span class="math inline">\infty</span>: la funzione <code>isinf</code> restituisce <code>true</code> se il numero floating-point è uno dei <a href="https://www.doc.ic.ac.uk/~eedwards/compsys/float/nan.html">tipi di infinito</a> supportati da <code>double</code>.</p>
<p>Ovviamente dobbiamo usare il metodo del mid-point con la seconda integranda, perché il mid-right richiederebbe di calcolarla in <span class="math inline">x = 2</span>, dove non è definita. Dobbiamo anche ricordarci di confrontare il valore stimato dell’integrale con <code>true_value2</code> (ossia <span class="math inline">\pi / 2</span>) anziché <code>true_value1</code>:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  test_code<span class="op">();</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #7</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;We must use mid-point, otherwise the function to integrate is &quot;</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;estimated outside of its domain.</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>  Funzione2 fun2<span class="op">;</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  ErrorTable fun2_results<span class="op">{</span>calculate_errors<span class="op">(</span>midpoint<span class="op">,</span> fun2<span class="op">,</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>                                           true_value2<span class="op">,</span> <span class="st">&quot;point7.png&quot;</span><span class="op">)};</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questo è l’output:</p>
<pre><code># Point #7

We must use mid-point, otherwise the function to integrate is estimated outside of its domain.

Error table:

     N                h               Value             Error     Estimated error
     2    8.2436064e-01       1.2723267e+00     2.9846960e-01       2.9846960e-01
     4    4.1218032e-01       1.3583103e+00     2.1248598e-01       2.1136014e-01
     8    2.0609016e-01       1.4200533e+00     1.5074307e-01       1.4967390e-01
    16    1.0304508e-01       1.4640336e+00     1.0676275e-01       1.0599102e-01
    32    5.1522540e-02       1.4952436e+00     7.5552682e-02       7.5057145e-02
    64    2.5761270e-02       1.5173514e+00     5.3444936e-02       5.3151439e-02
   128    1.2880635e-02       1.5329976e+00     3.7798727e-02       3.7638994e-02
   256    6.4403175e-03       1.5440660e+00     2.6730367e-02       2.6653914e-02
   512    3.2201587e-03       1.5518942e+00     1.8902153e-02       1.8874870e-02
  1024    1.6100794e-03       1.5574302e+00     1.3366169e-02       1.3366169e-02


k₁ = 0.33, k₂ = 0.50</code></pre>
<p>e questo è il grafico:</p>
<p><img src="images/exam1-point7.png" /></p>
<h1 id="temaB">Tema 2 (equazioni differenziali)</h1>
<p>Questo è il link per aprire il testo: <a href="https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_2.pdf" class="uri">https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_2.pdf</a></p>
<h2 id="temaBLetturaTesto">Lettura del testo</h2>
<p>Nello svolgimento del <a href="#temaA">primo esercizio</a> abbiamo mostrato come svolgere un’efficace <a href="#letturaTestoA">lettura del testo</a>, ma non abbiamo spiegato <em>come</em> si può arrivare a leggere l’enunciato di un tema d’esame in un modo efficace. Qui faremo quindi un lavoro più dettagliato dal punto di vista pratico: fingeremo di avere a disposizione un foglio di carta su cui segneremo le cose importanti da fare. All’inizio lasceremo cinque caselle vuote, una per ogni punto riportato nel testo:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>?</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Leggeremo il tema punto per punto come abbiamo fatto per il Tema 1, e annoteremo in questa lista le cose importanti.</p>
<p>Il primo punto chiede di usare il metodo Runge-Kutta per risolvere un’equazione differenziale del secondo ordine, quindi dovremo recuperare il testo dell’<a href="carminati-esercizi-08.html#esercizio-8.2">esercizio 8.2</a>. Richiede di stimare la posizione alla fine della simulazione, quindi si tratta di scrivere un ciclo <code>while</code> che aumenta il tempo <code>t</code> finché non raggiunge il tempo finale: nulla di difficile, è praticamente identico all’esercizio 8.2, anche se qui ci chiede di usare un “passo <span class="math inline">h</span> di integrazione opportuno”. Aggiorniamo quindi il nostro foglio:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stima un buon valore per <span class="math inline">h</span>, usa RK fino al tempo finale e stampa posizione (es. 8.2)</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Passiamo al secondo punto, che richiede di stimare l’errore nella posizione. Dobbiamo ricordarci che il metodo Runge-Kutta è un metodo del <em>quarto</em> ordine (sapete bene la teoria, vero?!? 🫵), e usare quindi le formule insegnate a lezione per stimare l’errore quando non si conosce la soluzione analitica: risolvere il problema con passo <span class="math inline">h</span>, poi con passo <span class="math inline">h/2</span>, e poi combinare i due risultati. Aggiorniamo il nostro foglio:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stima un buon valore per <span class="math inline">h</span>, usa RK fino al tempo finale e stampa posizione (es. 8.2)</p></li>
<li><p>Usa RK con <span class="math inline">h/2</span> fino al tempo finale, poi combina il risultato con la stima del punto 1</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Veniamo al terzo punto, che richiede di stimare <span class="math inline">h</span> in modo da ottenere un preciso errore sulla posizione. Questo si potrà stimare sapendo che <span class="math inline">\varepsilon \propto h^4</span> (la teoria, la teoria!), quindi possiamo aggiornare il nostro foglio:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stima un buon valore per <span class="math inline">h</span>, usa RK fino al tempo finale e stampa posizione (es. 8.2)</p></li>
<li><p>Usa RK con <span class="math inline">h/2</span> fino al tempo finale, poi combina il risultato con la stima del punto 1</p></li>
<li><p>Calcola il valore di <span class="math inline">h</span> richiesto usando la formula analitica dell’errore</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Il punto 4 richiede di eseguire una simulazione Monte Carlo, stimando l’errore sulla posizione al tempo finale; dovremo quindi usare il generatore di numeri casuali dell’<a href="carminati-esercizi-10.html#esercizio-10.0">esercizio 10.0</a>. Il nostro foglio diventa questo:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stima un buon valore per <span class="math inline">h</span>, usa RK fino al tempo finale e stampa posizione (es. 8.2)</p></li>
<li><p>Usa RK con <span class="math inline">h/2</span> fino al tempo finale, poi combina il risultato con la stima del punto 1</p></li>
<li><p>Calcola il valore di <span class="math inline">h</span> richiesto usando la formula analitica dell’errore</p></li>
<li><p>Esegui MC 1000 volte per stimare l’errore sulla posizione al tempo finale (es. 10.0)</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Infine, l’ultimo punto richiede di ripetere il punto 4 con valori diversi dell’errore e stampare una tabella in cui si mostra l’andamento dell’errore della posizione; dovremo quindi usare il codice per la deviazione standard implementato nell’<a href="carminati-esercizi-03.html#esercizio-3.1">esercizio 3.1</a>. Con questo abbiamo completato la nostra tabellina sul foglio di brutta:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stima un buon valore per <span class="math inline">h</span>, usa RK fino al tempo finale e stampa posizione (es. 8.2)</p></li>
<li><p>Usa RK con <span class="math inline">h/2</span> fino al tempo finale, poi combina il risultato con la stima del punto 1</p></li>
<li><p>Calcola il valore di <span class="math inline">h</span> richiesto usando la formula analitica dell’errore</p></li>
<li><p>Esegui MC 1000 volte per stimare l’errore sulla posizione al tempo finale (es. 10.0)</p></li>
<li><p>Esegui di nuovo MC per vari valori dell’errore su v₀ (es. 3.1)</p></li>
</ol>
</blockquote>
<p>Leggendo questa lista, possiamo capire che ci sono una ridotta serie di compiti che vanno ripetuti più e più volte:</p>
<ul>
<li>Eseguire una simulazione RK con un passo fissato finché non si raggiunge il tempo <span class="math inline">t = 43\,\text{s}</span> (punti 1, 2, 4, 5);</li>
<li>Eseguire un Monte Carlo facendo variare il valore di <span class="math inline">v_0</span> e stimando l’errore sulla posizione al tempo <span class="math inline">t = 43\,\text{s}</span> (punti 4 e 5).</li>
</ul>
<p>Notiamo anche che il secondo punto di questa lista può basarsi sul codice del primo. Dovremo quindi implementare due funzioni:</p>
<ol type="1">
<li><p>Una funzione <code>estimate_end_position()</code> che esegua il metodo RK:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> estimate_end_position<span class="op">(</span><span class="dt">double</span> vx0<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span> <span class="dt">int</span> nsteps<span class="op">,</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>                             <span class="at">const</span> string <span class="op">&amp;</span>file_name <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span></code></pre></div>
<p>La funzione deve accettare il valore di <span class="math inline">v_0</span> in modo da poter implementare i punti 4 e 5, in cui questo valore va estratto casualmente, il passo <span class="math inline">h</span> e il numero di step <span class="math inline">N</span> da compiere, e per facilitare il debugging passiamo un nome di file PNG in cui salvare un grafico col risultato della simulazione, analogamente a come avevamo fatto nello svolgimento del tema d’esame n. 1.</p></li>
<li><p>Una funzione che esegua la simulazione Monte Carlo:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> estimate_stddev_from_mc<span class="op">(</span>RandomGen <span class="op">&amp;</span>rnd<span class="op">,</span> <span class="dt">double</span> err_on_vx0<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">int</span> nsteps<span class="op">,</span> <span class="dt">bool</span> debug_print <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span></code></pre></div>
<p>Questa funzione dovrà accettare un generatore di numeri casuali di tipo <code>RandomGen</code> (un <strong>reference</strong>, attenzione!), la deviazione standard <code>err_on_vx0</code> della Gaussiana su <span class="math inline">v_0</span>, il passo <code>h</code> e il numero <span class="math inline">N</span> di step, e un flag che decida se vogliamo stampare a video informazioni di debugging o no.</p>
<p>È importante che <code>RandomGen</code> venga passato come parametro e non creato all’interno della funzione <code>estimate_stddev_from_mc()</code>. Se implementassimo la funzione così:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">// No parameter `RandomGen &amp;rnd` at the beginning</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> estimate_stddev_from_mc<span class="op">(</span><span class="dt">double</span> err_on_vx0<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">int</span> nsteps<span class="op">,</span> <span class="dt">bool</span> debug_print <span class="op">=</span> <span class="kw">false</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    RandomGen rnd<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>allora ogni volta che si invoca la funzione verrebbero sempre generati gli stessi numeri pseudocasuali, e questo potrebbe portare a risultati strani! Ricordatevi di creare <strong>sempre</strong> l’istanza della classe <code>RandomGen</code> nel <code>main()</code> e di passarla a ogni funzione che ne faccia uso!</p></li>
</ol>
<h2 id="temaBpuntoA">Implementazione del punto 1</h2>
<p>Iniziamo col definire alcune costanti:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// ω₀ of the harmonic oscillator [s⁻¹]</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> omega0<span class="op">{</span><span class="fl">1.15</span><span class="op">};</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co">/// Dumping factor α [s]</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> alpha<span class="op">{</span><span class="fl">0.01</span><span class="op">};</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co">/// Duration of the simulation [s]</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> end_time<span class="op">{</span><span class="fl">43.0</span><span class="op">};</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="co">/// Start point of the oscillator [m]</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> x0<span class="op">{</span><span class="fl">1.0</span><span class="op">};</span></span></code></pre></div>
<p>A titolo di esempio, in questo codice sfrutteremo l’idea esposta sopra nel paragrafo <a href="#template">Usare i template al posto di gerarchie di classi</a> per implementare il metodo di Runge-Kutta (l’idea è quella che lo facciate <em>prima</em> di presentarvi allo scritto, se vi è piaciuta l’idea di usare i template e ve la sentite di farlo!). Ovviamente però il tema d’esame si può risolvere perfettamente anche col vecchio approccio degli oggetti e di <code>FunzioneVettorialeBase</code>: l’implementazione sarà semplicemente più lunga e verbosa, ma i punti spiegati in questi paragrafi si applicheranno ugualmente.</p>
<p>Questa è la definizione template di Runge-Kutta:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">size_t</span> N<span class="op">&gt;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> runge_kutta<span class="op">(</span><span class="dt">double</span> t<span class="op">,</span> array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> v<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span> <span class="kw">auto</span> fn<span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> k1 <span class="op">=</span> fn<span class="op">(</span>t<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> k2 <span class="op">=</span> fn<span class="op">(</span>t <span class="op">+</span> <span class="op">(</span>h <span class="op">/</span> <span class="fl">2.</span><span class="op">),</span> v <span class="op">+</span> k1 <span class="op">*</span> <span class="op">(</span>h <span class="op">/</span> <span class="fl">2.</span><span class="op">));</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> k3 <span class="op">=</span> fn<span class="op">(</span>t <span class="op">+</span> <span class="op">(</span>h <span class="op">/</span> <span class="fl">2.</span><span class="op">),</span> v <span class="op">+</span> k2 <span class="op">*</span> <span class="op">(</span>h <span class="op">/</span> <span class="fl">2.</span><span class="op">));</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span>T<span class="op">,</span> N<span class="op">&gt;</span> k4 <span class="op">=</span> fn<span class="op">(</span>t <span class="op">+</span> h<span class="op">,</span> v <span class="op">+</span> k3 <span class="op">*</span> h<span class="op">);</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> v <span class="op">+</span> <span class="op">(</span>k1 <span class="op">+</span> <span class="fl">2.</span> <span class="op">*</span> k2 <span class="op">+</span> <span class="fl">2.</span> <span class="op">*</span> k3 <span class="op">+</span> k4<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>h <span class="op">/</span> <span class="fl">6.</span><span class="op">);</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>dove ho usato <code>template</code> ma anche la comoda scorciatoia <code>auto fn</code> garantita dal C++20. In questo modo, non ho bisogno di derivare una classe da <code>FunzioneVettorialeBase</code> dove ridefinisco <code>Eval</code>, ma definisco direttamente la funzione che descrive l’equazione differenziale in uno spazio delle fasi 2D:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;array&gt;</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="co">/// Dumped 1D harmonic oscillator</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> oscill<span class="op">(</span><span class="dt">double</span> t<span class="op">,</span> array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Neat trick: *always* assign the components of the vector `v` to</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// variables with a meaningful name, e.g., `x`, `y`, `vx`, `vy`, etc.</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// This make the formula below easier to read, and it costs nothing</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// in terms of performance, as the compiler will optimize `x` and</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// `vx` away.</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> x<span class="op">{</span>v<span class="op">[</span><span class="dv">0</span><span class="op">]};</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> vx<span class="op">{</span>v<span class="op">[</span><span class="dv">1</span><span class="op">]};</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>  array result<span class="op">{</span>vx<span class="op">,</span> <span class="op">-</span>pow<span class="op">(</span>omega0<span class="op">,</span> <span class="fl">2.0</span><span class="op">)</span> <span class="op">*</span> x <span class="op">-</span> alpha <span class="op">*</span> vx<span class="op">};</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Sarebbe buona cosa ora implementare alcuni test, come abbiamo fatto nell’esercizio 1, per verificare che abbiamo implementato correttamente la funzione <code>oscill()</code>; lascio l’esercizio a voi.</p>
<p>Come recita il nostro foglio, dobbiamo ora implementare una funzione che iteri il metodo di Runge-Kutta fino a un tempo finale:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> estimate_end_position<span class="op">(</span><span class="dt">double</span> vx0<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span> <span class="dt">int</span> nsteps<span class="op">,</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>                             <span class="at">const</span> string <span class="op">&amp;</span>file_name <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  array pos<span class="op">{</span>x0<span class="op">,</span> vx0<span class="op">};</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> time<span class="op">(</span>nsteps<span class="op">);</span>      <span class="co">// Pre-allocate `nsteps` elements</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> position<span class="op">(</span>nsteps<span class="op">);</span>  <span class="co">// Ditto</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> t<span class="op">{};</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> nsteps<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    time<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a>    position<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> pos<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> runge_kutta<span class="op">(</span>t<span class="op">,</span> pos<span class="op">,</span> h<span class="op">,</span> oscill<span class="op">);</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>    t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>file_name<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a plot of the solution</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>    Gnuplot gpl<span class="op">;</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>    gpl<span class="op">.</span>redirect_to_png<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>    gpl<span class="op">.</span>plot<span class="op">(</span>time<span class="op">,</span> position<span class="op">);</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a>    gpl<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Time [s]&quot;</span><span class="op">);</span></span>
<span id="cb69-22"><a href="#cb69-22" aria-hidden="true" tabindex="-1"></a>    gpl<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;Position [m]&quot;</span><span class="op">);</span></span>
<span id="cb69-23"><a href="#cb69-23" aria-hidden="true" tabindex="-1"></a>    gpl<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb69-24"><a href="#cb69-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb69-25"><a href="#cb69-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-26"><a href="#cb69-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Return the value of x at the end of the simulation</span></span>
<span id="cb69-27"><a href="#cb69-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> pos<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb69-28"><a href="#cb69-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Come avevamo scritto sopra, aggiungiamo la facoltà di salvare un grafico della soluzione: sarà utile per fare debugging.</p>
<p>A questo punto, possiamo risolvere il primo punto nel <code>main()</code> invocando <code>estimate_end_position</code>.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> exam2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>  test_euler<span class="op">();</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>  test_runge_kutta<span class="op">();</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 1</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="dt">double</span> h<span class="op">{</span><span class="fl">0.05</span><span class="op">};</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> end_position_h<span class="op">{</span>estimate_end_position<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> h<span class="op">,</span> <span class="st">&quot;point1.png&quot;</span><span class="op">)};</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;End position at t = </span><span class="sc">{:.2f}</span><span class="st"> s with step h = </span><span class="sc">{:.2f}</span><span class="st"> s: </span><span class="sc">{:.5f}</span><span class="st"> m&quot;</span><span class="op">,</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>               end_time<span class="op">,</span> h<span class="op">,</span> end_position_h<span class="op">);</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;A plot has been saved in file point1.png</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questo è l’output del codice:</p>
<pre><code># Point 1

End position at t = 43.00 s with step h = 0.05 s: 0.55007 m
A plot has been saved in file point1.png</code></pre>
<p>e questo è il grafico prodotto:</p>
<p><img src="images/exam2-point1.png" /></p>
<p>Il risultato è quanto ci aspettiamo: si tratta proprio di un oscillatore armonico smorzato.</p>
<h2 id="temaBpuntoB">Implementazione del punto 2</h2>
<p>Per implementare il punto 2, dobbiamo eseguire di nuovo la simulazione con passo <span class="math inline">h / 2</span> (ossia con numero di passi <span class="math inline">2N</span>) e poi confrontare la posizione finale calcolata con passo <span class="math inline">h</span> con la nuova calcolata con passo <span class="math inline">h/2</span>; l’errore è dato dalla formula vista a lezione:</p>
<p><span class="math display">
\varepsilon = \frac{16}{15} \left|x_f^{(h)} - x_f^{(h/2)}\right|,
</span></p>
<p>dove <span class="math inline">x_f^{(h)}</span> e <span class="math inline">x_f^{(h/2)}</span> sono le posizioni finali calcolate nei due casi. Si tratta quindi banalmente di implementare la formula:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 2</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;End position: </span><span class="sc">{:.4f}</span><span class="st"> m&quot;</span><span class="op">,</span> end_position_h<span class="op">);</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="co">// We don&#39;t ask `estimate_end_position` to save a plot here</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> end_position_h2<span class="op">{</span>estimate_end_position<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> h <span class="op">/</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span> <span class="op">*</span> N<span class="op">)};</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> error_h<span class="op">{</span><span class="fl">16.</span> <span class="op">/</span> <span class="dv">15</span> <span class="op">*</span> abs<span class="op">(</span>end_position_h <span class="op">-</span> end_position_h2<span class="op">)};</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Error on the end position (h = </span><span class="sc">{}</span><span class="st"> s): </span><span class="sc">{:.2e}</span><span class="st"> m</span><span class="sc">\n</span><span class="st">, h, error_h);</span></span></code></pre></div>
<p>L’output del programma è il seguente:</p>
<pre><code># Point 2

End position: 0.5501 m
Error on the end position (h = 0.05 s): 2.73e-06 m</code></pre>
<h2 id="temaBpuntoC">Implementazione del punto 3</h2>
<p>Anche in questo caso basta aver presente la teoria per risolvere facilmente questo punto. L’errore <span class="math inline">\varepsilon</span> del metodo di Runge-Kutta è tale che <span class="math inline">\varepsilon = k h^4</span>; di solito nei problemi numerici è meglio però ricondursi al numero di step <span class="math inline">N = t_f / h</span>, perché è un numero intero e non è soggetto agli arrotondamenti tipici dei numeri floating-point. Riscriviamo quindi <span class="math inline">\varepsilon</span> come</p>
<p><span class="math display">
\varepsilon = k \left(\frac{t_f}N\right)^4,
</span></p>
<p>da cui</p>
<p><span class="math display">
k = \varepsilon \cdot \left(\frac{N}{t_f}\right)^{1/4}.
</span></p>
<p>e di conseguenza</p>
<p><span class="math display">
N = \left(\frac{k}{\varepsilon}\right)^{1/4} \cdot t_f.
</span></p>
<p>Se vogliamo ottenere un errore <span class="math inline">\varepsilon&#39;</span>, avremo quindi bisogno di un numero di passi <span class="math inline">N&#39;</span> tale che</p>
<p><span class="math display">
N&#39; = \left(\frac{k}{\varepsilon&#39;}\right)^{1/4} \cdot t_f = N \left(\frac{\varepsilon}{\varepsilon&#39;}\right)^{1/4}
</span></p>
<p>che ha una forma ragionevole: se vogliamo un errore più piccolo (<span class="math inline">\varepsilon&#39; &lt; \varepsilon</span>), allora <span class="math inline">N&#39; &gt; N</span> e quindi dobbiamo aumentare il numero di punti. Il punto 3 si risolve quindi con poche righe di codice:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> target_error<span class="op">{</span><span class="fl">50e-6</span><span class="op">};</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> new_N<span class="op">{</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>N <span class="op">*</span> pow<span class="op">(</span>error_h <span class="op">/</span> target_error<span class="op">,</span> <span class="fl">0.25</span><span class="op">))};</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> new_h<span class="op">{</span>end_time <span class="op">/</span> new_N<span class="op">};</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Number of steps required to reach an error ε = </span><span class="sc">{}</span><span class="st"> m: </span><span class="sc">{}</span><span class="st"> (h&#39; = &quot;</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>           <span class="st">&quot;</span><span class="sc">{:.2e}</span><span class="st"> s)</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>           target_error<span class="op">,</span> new_N<span class="op">,</span> new_h<span class="op">);</span></span></code></pre></div>
<p>Questo è l’output:</p>
<pre><code># Point 3

Number of steps required to reach an error ε = 5e-05 m: 415 (h&#39; = 1.04e-01 s)</code></pre>
<h2 id="temaBpuntoD">Implementazione del punto 4</h2>
<p>Arrivati a questo punto, ci ricordiamo che nella nostra lettura del testo avevamo stabilito di implementare una funzione che esegue la simulazione Monte Carlo:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> estimate_stddev_from_mc<span class="op">(</span>RandomGen <span class="op">&amp;</span>rnd<span class="op">,</span> <span class="dt">double</span> err_on_vx0<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">int</span> nsteps<span class="op">,</span> <span class="dt">bool</span> debug_print <span class="op">=</span> <span class="kw">false</span><span class="op">);</span></span></code></pre></div>
<p>Il parametro <code>err_on_vx0</code> è il valore in m/s dell’errore sulla stima della velocità iniziale <span class="math inline">v_x(t = 0)</span>. L’implementazione fa uso delle funzioni <code>mean</code> e <code>stderr</code> che avete implementato nell’<a href="carminati-esercizi-03.html#esercizio-3.1">esercizio 3.1</a>:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Be sure to use a *reference* for `RandomGen`!</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> estimate_stddev_from_mc<span class="op">(</span>RandomGen <span class="op">&amp;</span>rnd<span class="op">,</span> <span class="dt">double</span> err_on_vx0<span class="op">,</span> <span class="dt">double</span> h<span class="op">,</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>                               <span class="dt">int</span> nsteps<span class="op">,</span> <span class="dt">bool</span> debug_print <span class="op">=</span> <span class="kw">false</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Run the Monte Carlo</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> samples<span class="op">(</span><span class="dv">10&#39;000</span><span class="op">);</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> ssize<span class="op">(</span>samples<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> vx0 <span class="op">=</span> rnd<span class="op">.</span>gauss<span class="op">(</span><span class="fl">0.0</span><span class="op">,</span> err_on_vx0<span class="op">);</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Don&#39;t save the plot in a PNG file, for Heaven&#39;s sake!!!</span></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    samples<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> estimate_end_position<span class="op">(</span>vx0<span class="op">,</span> h<span class="op">,</span> nsteps<span class="op">);</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Estimate the statistical parameters</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> avg<span class="op">{</span>mean<span class="op">(</span>samples<span class="op">)};</span></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> err<span class="op">{</span>stddev<span class="op">(</span>samples<span class="op">)};</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// When needed, print these parameters to debug the code</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>debug_print<span class="op">)</span> <span class="op">{</span></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;Position from MC samples: </span><span class="sc">{:.5f}</span><span class="st"> ± </span><span class="sc">{:.5f}</span><span class="st"> m&quot;</span><span class="op">,</span> avg<span class="op">,</span> err<span class="op">);</span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Just return the error</span></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> err<span class="op">;</span></span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Una volta implementata questa funzione, è sufficiente invocarla nel <code>main()</code>:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 4</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>RandomGen rnd<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> mc_error<span class="op">{</span>estimate_stddev_from_mc<span class="op">(</span>rnd<span class="op">,</span> <span class="fl">3e-3</span><span class="op">,</span> new_h<span class="op">,</span> new_N<span class="op">,</span> <span class="kw">true</span><span class="op">)};</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Error on the end position estimated from MC: </span><span class="sc">{:.2f}</span><span class="st"> mm</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>           mc_error <span class="op">*</span> <span class="fl">1e3</span><span class="op">);</span></span></code></pre></div>
<p>Questo è l’output:</p>
<pre><code># Point 4

Position from MC samples: 0.55003 ± 0.00154 m
Error on the end position estimated from MC: 1.54 mm</code></pre>
<h2 id="temaBpuntoE">Implementazione del punto 5</h2>
<p>Il punto 5 richiede semplicemente di invocare la funzione <code>estimate_stddev_from_mc()</code> più volte e salvare gli errori nel vettore <code>error_list</code>:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 5</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> prec_mm_list<span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">15</span><span class="op">};</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> error_list<span class="op">;</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> cur_prec_mm <span class="op">:</span> prec_mm_list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>  error_list<span class="op">.</span>push_back<span class="op">(</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>      estimate_stddev_from_mc<span class="op">(</span>rnd<span class="op">,</span> cur_prec_mm <span class="op">*</span> <span class="fl">1e-3</span><span class="op">,</span> new_h<span class="op">,</span> new_N<span class="op">));</span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}\t{:.6f}</span><span class="st">&quot;</span><span class="op">,</span> cur_prec_mm<span class="op">,</span> error_list<span class="op">.</span>back<span class="op">());</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>Gnuplot plt<span class="op">{};</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>redirect_to_png<span class="op">(</span><span class="st">&quot;error_plot.png&quot;</span><span class="op">);</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>plot<span class="op">(</span>prec_mm_list<span class="op">,</span> error_list<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">,</span> Gnuplot<span class="op">::</span>LineStyle<span class="op">::</span>LINESPOINTS<span class="op">);</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Error on the velocity [mm/s]&quot;</span><span class="op">);</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;Error on the final position [m]&quot;</span><span class="op">);</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Plot saved to error_plot.png&quot;</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span></code></pre></div>
<p>Questo è il plot prodotto dal programma:</p>
<p><img src="images/exam2-point5.png" /></p>
<h1 id="temaC">Tema 3 (equazioni differenziali, Monte Carlo)</h1>
<p>Questo è il link per aprire il testo: <a href="https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_3.pdf" class="uri">https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_3.pdf</a></p>
<h2 id="lettura-del-testo">Lettura del testo</h2>
<p>Il testo consiste di tre domande, quindi ci aspettiamo che almeno una di esse sia abbastanza articolata. E infatti già la lettura del primo punto presenta una complicazione: occorre simulare l’orbita di una particella in un moto periodico, usando Runge-Kutta, e contare il numero di rivoluzioni attorno all’origine per capire quando arrestare la simulazione. Si tratta quindi di qualcosa di un po’ più complesso dell’<a href="carminati-esercizi-08.html#esercizio-8.2">esercizio 8.2</a>, dove bastava iterare finché non si raggiungeva un tempo finale.</p>
<p>Nel nostro foglio degli appunti, annotiamo quindi questo:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Usare RK e iterare finché la particella non compie 10 rivoluzioni (es. 8.2)</p></li>
<li><p>?</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Il punto 2 è decisamente diverso dal primo: qui non si devono contare le rivoluzioni della particella attorno all’origine, ma semplicemente eseguire la simulazione fino a un tempo fissato per due espressioni diverse del campo magnetico, e paragonare i risultati. Di conseguenza, non ha molto senso reimpiegare quanto abbiamo implementato nel punto 1, magari racchiudendolo in una funzione, per poterlo invocare anche nel punto 2: si tratta proprio di codici diversi. Piuttosto, qui dobbiamo impostare il nostro codice in modo che sia facile passare l’una (<span class="math inline">\alpha = +2</span>) o l’altra (<span class="math inline">\alpha = -2</span>) formulazione del campo. Dobbiamo anche stare attenti al fatto che la condizione iniziale è diversa da quella del punto 2 (<span class="math inline">x_0 = 1.1\,\text{m}</span> anziché <span class="math inline">x_0 = 1\,\text{m}</span>).</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Usare RK e iterare finché la particella non compie 10 rivoluzioni (es. 8.2)</p></li>
<li><p>Usare RK per un tempo fissato sui casi <span class="math inline">\alpha = \pm 2</span> e fare il grafico</p></li>
<li><p>?</p></li>
</ol>
</blockquote>
<p>Resta ora da leggere il punto 3, che è identico al punto 2 ma richiede di usare una nuova formulazione del campo. Ecco quindi come appare il nostro foglio degli appunti:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Usare RK e iterare finché la particella non compie 10 rivoluzioni (es. 8.2)</p></li>
<li><p>Usare RK per un tempo fissato sui casi <span class="math inline">\alpha = \pm 2</span> e fare il grafico</p></li>
<li><p>Usare RK per un tempo fissato usando una nuova formulazione per <span class="math inline">B(r)</span></p></li>
</ol>
</blockquote>
<p>Rileggendo il foglio, vediamo che il punto 1 è concettualmente diverso dagli altri due, ma il punto 2 e il punto 3 sono molto simili; di conseguenza, ha senso definire una funzione che possa essere usata sia nello svolgimento di entrambi i punti. Possiamo ipotizzare che il prototipo della funzione sia</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> simulate_for_a_fixed_time<span class="op">(</span><span class="dt">double</span> x0<span class="op">,</span> FunzioneVettorialeBase <span class="op">&amp;</span> synchrotron_fn<span class="op">,</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>                                 string file_name<span class="op">);</span></span></code></pre></div>
<p>dove <code>x0</code> è la condizione iniziale, <code>synchrotron_fn</code> è la funzione da integrare con Runge-Kutta, e <code>file_name</code> è il nome del file PNG che conterrà il grafico. Noi seguiremo però l’approccio delle funzioni <a href="#template">template</a>, quindi il nostro prototipo sarà:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> simulate_for_a_fixed_time<span class="op">(</span><span class="dt">double</span> x0<span class="op">,</span> <span class="kw">auto</span> synchrotron_fn<span class="op">,</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>                                 string file_name<span class="op">);</span></span></code></pre></div>
<p>Con una funzione così, una volta risolto il punto 2 è banale risolvere anche il punto 3.</p>
<h2 id="temaCpuntoA">Implementazione del punto 1</h2>
<p>Dobbiamo innanzitutto definire alcune costanti per <span class="math inline">h</span>, il numero di orbite da considerare nel punto 1, e il tempo finale della simulazione ai punti 2 e 3:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numbers&gt;</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">double</span> h<span class="op">{</span><span class="fl">0.02</span><span class="op">};</span>  <span class="co">// Pick any value you want, provided that it&#39;s small enough</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> num_of_loops_point1<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">double</span> max_time<span class="op">{</span><span class="dv">10</span> <span class="op">*</span> numbers<span class="op">::</span>pi<span class="op">};</span></span></code></pre></div>
<p>Ci serve implementare la funzione che esprime il campo del sincrotrone, ma vogliamo renderla abbastanza generica da essere usabile nello svolgimento di tutti i tre punti. L’espressione più generica che comprenda tutti i casi previsti nel testo è ovviamente</p>
<p><span class="math display">
B(r) = \frac1{r^\alpha} + c,
</span></p>
<p>considerando per il punto 1 i valori <span class="math inline">\alpha = 0</span>, <span class="math inline">c = 0</span>, per il punto 2 <span class="math inline">\alpha = \pm 2</span>, <span class="math inline">c = 0</span>, per il punto 3 <span class="math inline">\alpha = 2</span>, <span class="math inline">c = 1</span>. Essendo una funzione che richiede parametri, definiamo una classe con membri pubblici e usiamo i <a href="#functori">functori</a>:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Synchrotron <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> alpha<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">double</span> t<span class="op">,</span> array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>(Usando l’approccio template, non abbiamo bisogno di derivare la classe da <code>FunzioneVettorialeBase</code>: scrivere codice così è più veloce).</p>
<p>Per implementare la funzione da integrare è bene evitare ripetizioni e definire funzioni di supporto: questo renderà il codice più modulare e più facile da correggere. Decidiamo quindi di implementare queste funzioni anziché buttarci subito a riempire la definizione di <code>Synchrotron::operator()</code>:</p>
<ul>
<li><p>Una funzione che, data una coppia di punti <span class="math inline">(x, y)</span>, calcola la loro distanza <span class="math inline">r = \sqrt{x^2 + y^2}</span> dall’origine: questo perché il campo <span class="math inline">B</span> è espresso nel testo del tema d’esame in funzione della distanza <span class="math inline">r</span>, e non delle semplici coordinate cartesiane <span class="math inline">(x, y)</span>.</p></li>
<li><p>Una funzione che restituisce il valore di <span class="math inline">B(r)</span>, dati ovviamente i valori <span class="math inline">\alpha</span> e <span class="math inline">c</span>.</p></li>
<li><p>La funzione quadridimensionale data nel testo del tema d’esame, da integrare con Runge-Kutta.</p></li>
</ul>
<p>Questa è una possibile implementazione:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> distance<span class="op">(</span><span class="dt">double</span> x<span class="op">,</span> <span class="dt">double</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> sqrt<span class="op">(</span>x <span class="op">*</span> x <span class="op">+</span> y <span class="op">*</span> y<span class="op">);</span> <span class="op">}</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Synchrotron <span class="op">{</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> alpha<span class="op">,</span> c<span class="op">;</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> bfield<span class="op">(</span><span class="dt">double</span> r<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> pow<span class="op">(</span>r<span class="op">,</span> alpha<span class="op">)</span> <span class="op">+</span> c<span class="op">;</span> <span class="op">}</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>  array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">double</span> t<span class="op">,</span> array<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> x<span class="op">{</span>v<span class="op">[</span><span class="dv">0</span><span class="op">]};</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> y<span class="op">{</span>v<span class="op">[</span><span class="dv">1</span><span class="op">]};</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> vx<span class="op">{</span>v<span class="op">[</span><span class="dv">2</span><span class="op">]};</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> vy<span class="op">{</span>v<span class="op">[</span><span class="dv">3</span><span class="op">]};</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> r<span class="op">{</span>distance<span class="op">(</span>x<span class="op">,</span> y<span class="op">)};</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>    array result<span class="op">{</span>vx<span class="op">,</span> vy<span class="op">,</span> <span class="op">-</span>bfield<span class="op">(</span>r<span class="op">)</span> <span class="op">*</span> vy<span class="op">,</span> bfield<span class="op">(</span>r<span class="op">)</span> <span class="op">*</span> vx<span class="op">};</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Potreste chiedervi perché ho definito <code>distance</code> come una funzione <em>fuori</em> da <code>Synchrotron</code>, mentre ho dichiarato <code>bfield</code> come un metodo della classe. Si tratta di gusto personale: non sarebbe stato sbagliato rendere <code>distance</code> una funzione membro di <code>Synchrotron</code> esattamente come <code>bfield</code>; ho preferito fare così perché <code>distance</code> non usa alcuna variabile membro di <code>Synchrotron</code> (<code>alpha</code> e <code>c</code>), mentre <code>bfield</code> sì.</p>
<p>Come nei temi precedenti, sarebbe bene implementare alcuni test per verificare che <code>Synchrotron</code> calcoli valori giusti; lascio a voi l’implementazione di <code>test_code()</code>:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_code<span class="op">()</span> <span class="op">{</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Put here a few tests for `distance`, `bfield`, etc.</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>  cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;All the tests passed. Hurrah!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>  test_code<span class="op">();</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Dobbiamo ora implementare il codice che risolve il punto 1. Queste sono le cose da fare:</p>
<ol type="1">
<li>Creare un’istanza di <code>Synchrotron</code> con i valori di <span class="math inline">\alpha</span> e <span class="math inline">c</span> appropriati;</li>
<li>Integrare con Runge-Kutta, contando quante volte il segno della componente <span class="math inline">y</span> si inverte e interrompendosi dopo la decima inversione;</li>
<li>Fare un’interpolazione lineare per stabilire qual era l’ultima posizione in cui <span class="math inline">y = 0</span>.</li>
</ol>
<p>Il primo punto è semplice:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>Synchrotron synchrotron_point1<span class="op">{</span><span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">};</span></span></code></pre></div>
<p>Scriviamo ora il codice che esegue l’integrazione di Runge-Kutta per 10 rivoluzioni, e nel contempo fa il plot della soluzione:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #1</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> loop_counter<span class="op">{};</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>array pos<span class="op">{</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">};</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> t<span class="op">{};</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>Gnuplot gpl<span class="op">{};</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>redirect_to_png<span class="op">(</span><span class="st">&quot;point1.png&quot;</span><span class="op">);</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Going to plot the trajectory for point #1 in file &#39;point.png&#39;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> prev_y<span class="op">;</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> cur_y<span class="op">;</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>add_point<span class="op">(</span>pos<span class="op">[</span><span class="dv">0</span><span class="op">],</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>  prev_y <span class="op">=</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>  pos <span class="op">=</span> runge_kutta<span class="op">(</span>t<span class="op">,</span> pos<span class="op">,</span> h<span class="op">,</span> synchrotron_point1<span class="op">);</span></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>  t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>  cur_y <span class="op">=</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>cur_y <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> prev_y <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span>loop_counter<span class="op">;</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>loop_counter <span class="op">==</span> num_of_loops_point1<span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>      <span class="co">// This is useful for debugging</span></span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>      fmt<span class="op">::</span>print<span class="op">(</span><span class="st">&quot;Got a full loop (#</span><span class="sc">{}</span><span class="st">) at t = </span><span class="sc">{}</span><span class="st"> with x = </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>                 loop_counter<span class="op">,</span> t<span class="op">,</span> cur_y<span class="op">);</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;x [m]&quot;</span><span class="op">);</span></span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;y [m]&quot;</span><span class="op">);</span></span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>plot<span class="op">();</span></span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-41"><a href="#cb88-41" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span></span>
<span id="cb88-42"><a href="#cb88-42" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;After </span><span class="sc">{}</span><span class="st"> loops I am at t = </span><span class="sc">{:.3f}</span><span class="st"> s, x = </span><span class="sc">{:.3e}</span><span class="st"> m, y = </span><span class="sc">{:.3e}</span><span class="st"> m&quot;</span><span class="op">,</span></span>
<span id="cb88-43"><a href="#cb88-43" aria-hidden="true" tabindex="-1"></a>    num_of_loops_point1<span class="op">,</span> t<span class="op">,</span> pos<span class="op">[</span><span class="dv">0</span><span class="op">],</span> cur_y<span class="op">);</span></span>
<span id="cb88-44"><a href="#cb88-44" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;Previous value of x was </span><span class="sc">{}</span><span class="st"> m&quot;</span><span class="op">,</span> prev_y<span class="op">);</span></span></code></pre></div>
<p>Anche se non abbiamo ancora terminato l’implementazione, compiliamo ed eseguiamo: è sempre bene verificare il prima possibile anche i risultati intermedi del nostro codice. Questo è l’output:</p>
<pre><code>All the tests passed. Hurrah!
# Point #1

Going to plot the trajectory for point #1 in file &#39;point.png&#39;
Got a full loop (#1) at t = 6.300 s with x = 0.01681389208438328
Got a full loop (#2) at t = 12.580 s with x = 0.013628946905430917
Got a full loop (#3) at t = 18.860 s with x = 0.010443863444984044
Got a full loop (#4) at t = 25.140 s with x = 0.007258674019620895
Got a full loop (#5) at t = 31.420 s with x = 0.004073410946994503
Got a full loop (#6) at t = 37.700 s with x = 0.000888106545507486
Got a full loop (#7) at t = 44.000 s with x = 0.017701866439014415
Got a full loop (#8) at t = 50.280 s with x = 0.014516965578546117
Got a full loop (#9) at t = 56.560 s with x = 0.011331917426545057
After 10 loops I am at t = 62.840 s, x = 1.000e+00 m, y = 8.147e-03 m
Previous value of x was -1.185e-02 m</code></pre>
<p>e questo è il grafico:</p>
<p><img src="images/exam3-point1.png" /></p>
<p>Questo risultato ci mostra che un periodo orbitale corrisponde a circa 6,3 s, e che (ovviamente) abbiamo già superato il punto in cui <span class="math inline">y = 0</span>, perché ora <span class="math inline">y = 8.147\times 10^{-3}\,\text{m}</span>. Dobbiamo quindi “riavvolgere” la simulazione, tornando indietro di un intervallo di tempo che ci consenta di collocarci ragionevolmente in un punto in cui <span class="math inline">y \approx 0</span>. Per farlo possiamo fare un’interpolazione lineare.</p>
<p>L’approccio più immediato sarebbe quello di interpolare tra il punto <span class="math inline">(t = t_\text{cur} - h&#39;, y = y_\text{prev})</span> e il punto <span class="math inline">(t = t_\text{cur}, y = y_\text{cur})</span>; però possiamo cambiare il nostro sistema di riferimento temporale e assumere che <span class="math inline">t_\text{cur} = 0</span>, in modo da rendere le formule più semplici. Dopotutto, a noi interessa solo <span class="math inline">h&#39;</span>, ossia di quanti secondi andare indietro nel tempo, non interessa sapere se quell’istante è venuto 100 o 120 secondi dopo l’inizio della simulazione…</p>
<p>Se scriviamo l’equazione della retta che passa per i punti <span class="math inline">(t = -h&#39;, y = y_\text{prev})</span> e i punti <span class="math inline">(t = 0, y = y_\text{cur})</span>, possiamo poi imporre <span class="math inline">y = 0</span> e risolvere per <span class="math inline">h&#39;</span>; la soluzione è</p>
<p><span class="math display">
t = -\frac{y_\text{cur}\cdot h&#39;}{y_\text{cur} - y_\text{prev}},
</span></p>
<p>che è correttamente un numero negativo: dobbiamo “tornare indietro” per una piccola frazione di secondo in modo da collocarci nella condizione <span class="math inline">y \approx 0</span>. A questo punto chiamiamo un’ultima volta <code>runge_kutta</code> con questo step negativo:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This is a *negative* time step: we jump back in time</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="co">// to the instant when we crossed the x axis</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> delta_time<span class="op">{-</span>h <span class="op">*</span> cur_y <span class="op">/</span> <span class="op">(</span>cur_y <span class="op">-</span> prev_y<span class="op">)};</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>delta_time <span class="op">&lt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s go back in time!</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> runge_kutta<span class="op">(</span>t<span class="op">,</span> pos<span class="op">,</span> delta_time<span class="op">,</span> synchrotron_point1<span class="op">);</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>t <span class="op">+=</span> delta_time<span class="op">;</span> <span class="co">// Remember that delta_time &lt; 0</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;Back to time t = </span><span class="sc">{:.4f}</span><span class="st"> s, x = </span><span class="sc">{:.3e}</span><span class="st"> m, y = </span><span class="sc">{:.3e}</span><span class="st"> m&quot;</span><span class="op">,</span> t<span class="op">,</span></span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>             pos<span class="op">[</span><span class="dv">0</span><span class="op">],</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>abs<span class="op">(</span>pos<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">&lt;</span> <span class="fl">1e-4</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Ok, we&#39;re within 10⁻⁴ m from zero.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>  cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;ERROR! Use a smaller value for h!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Se eseguiamo di nuovo il programma, otteniamo questo nuovo risultato in coda a quanto era già stampato:</p>
<pre><code>Back to time t = 62.8319 s, x = 1.000e+00 m, y = -5.966e-08 m
Ok, we&#39;re within 10⁻⁴ m from zero.</code></pre>
<h2 id="temaCpuntoB">Implementazione del punto 2</h2>
<p>Per implementare questo punto, abbiamo stabilito durante la lettura del testo che sarebbe bene implementare una funzione <code>simulate_for_a_fixed_time()</code> che accetti la condizione iniziale per <span class="math inline">x_0</span>, la funzione da integrare con Runge-Kutta, e il nome di un file in cui salvare il grafico in formato PNG.</p>
<p>Una possibile implementazione è la seguente:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// Return the distance from the center at the end of the simulation</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> simulate_for_a_fixed_time<span class="op">(</span><span class="dt">double</span> x0<span class="op">,</span> <span class="kw">auto</span> synchrotron_fn<span class="op">,</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>                                 string file_name<span class="op">)</span> <span class="op">{</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> nsteps<span class="op">{</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>max_time <span class="op">/</span> h <span class="op">+</span> <span class="fl">0.5</span><span class="op">)};</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>  Gnuplot gpl<span class="op">{};</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>redirect_to_png<span class="op">(</span>file_name<span class="op">);</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>multiplot<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>  array pos<span class="op">{</span>x0<span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">};</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> t<span class="op">{};</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Used for the plot on the left</span></span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> x_vec<span class="op">(</span>nsteps<span class="op">);</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> y_vec<span class="op">(</span>nsteps<span class="op">);</span></span>
<span id="cb92-16"><a href="#cb92-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-17"><a href="#cb92-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Used for the plot on the right</span></span>
<span id="cb92-18"><a href="#cb92-18" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> t_vec<span class="op">(</span>nsteps<span class="op">);</span></span>
<span id="cb92-19"><a href="#cb92-19" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> r_vec<span class="op">(</span>nsteps<span class="op">);</span></span>
<span id="cb92-20"><a href="#cb92-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-21"><a href="#cb92-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> nsteps<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb92-22"><a href="#cb92-22" aria-hidden="true" tabindex="-1"></a>    x_vec<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> pos<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb92-23"><a href="#cb92-23" aria-hidden="true" tabindex="-1"></a>    y_vec<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb92-24"><a href="#cb92-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-25"><a href="#cb92-25" aria-hidden="true" tabindex="-1"></a>    t_vec<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb92-26"><a href="#cb92-26" aria-hidden="true" tabindex="-1"></a>    r_vec<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">=</span> distance<span class="op">(</span>pos<span class="op">[</span><span class="dv">0</span><span class="op">],</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb92-27"><a href="#cb92-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-28"><a href="#cb92-28" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> runge_kutta<span class="op">(</span>t<span class="op">,</span> pos<span class="op">,</span> h<span class="op">,</span> synchrotron_fn<span class="op">);</span></span>
<span id="cb92-29"><a href="#cb92-29" aria-hidden="true" tabindex="-1"></a>    t <span class="op">+=</span> h<span class="op">;</span></span>
<span id="cb92-30"><a href="#cb92-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb92-31"><a href="#cb92-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-32"><a href="#cb92-32" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Left plot: x vs y</span></span>
<span id="cb92-33"><a href="#cb92-33" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;x [m]&quot;</span><span class="op">);</span></span>
<span id="cb92-34"><a href="#cb92-34" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;y [m]&quot;</span><span class="op">);</span></span>
<span id="cb92-35"><a href="#cb92-35" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>plot<span class="op">(</span>x_vec<span class="op">,</span> y_vec<span class="op">);</span></span>
<span id="cb92-36"><a href="#cb92-36" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb92-37"><a href="#cb92-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-38"><a href="#cb92-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Right plot: time vs distance</span></span>
<span id="cb92-39"><a href="#cb92-39" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;t [s]&quot;</span><span class="op">);</span></span>
<span id="cb92-40"><a href="#cb92-40" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>set_ylabel<span class="op">(</span><span class="st">&quot;Distance [m]&quot;</span><span class="op">);</span></span>
<span id="cb92-41"><a href="#cb92-41" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>plot<span class="op">(</span>t_vec<span class="op">,</span> r_vec<span class="op">);</span></span>
<span id="cb92-42"><a href="#cb92-42" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb92-43"><a href="#cb92-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-44"><a href="#cb92-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> distance<span class="op">(</span>pos<span class="op">[</span><span class="dv">0</span><span class="op">],</span> pos<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb92-45"><a href="#cb92-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Invochiamo la funzione due volte nel <code>main()</code>:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>Synchrotron synchrotron_point2_plus<span class="op">{+</span><span class="fl">2.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>Synchrotron synchrotron_point2_minus<span class="op">{-</span><span class="fl">2.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">};</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #2</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> r_plus<span class="op">{</span>simulate_for_a_fixed_time<span class="op">(</span><span class="fl">1.1</span><span class="op">,</span> synchrotron_point2_plus<span class="op">,</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>                                        <span class="st">&quot;point2_plus.png&quot;</span><span class="op">)};</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> r_minus<span class="op">{</span>simulate_for_a_fixed_time<span class="op">(</span><span class="fl">1.1</span><span class="op">,</span> synchrotron_point2_minus<span class="op">,</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>                                         <span class="st">&quot;point2_minus.png&quot;</span><span class="op">)};</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;Distance with α=+2: </span><span class="sc">{}</span><span class="st"> m, with α=−2: </span><span class="sc">{}</span><span class="st"> m&quot;</span><span class="op">,</span> r_plus<span class="op">,</span> r_minus<span class="op">);</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>r_plus <span class="op">&gt;</span> r_minus<span class="op">)</span> <span class="op">{</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;α=+2 makes the charge diverge</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;α=−2 makes the charge diverge</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Per <span class="math inline">\alpha = +2</span>, il grafico prodotto è questo:</p>
<p><img src="images/exam3-point2-plus.png" /></p>
<p>mentre per <span class="math inline">\alpha = -2</span> è</p>
<p><img src="images/exam3-point2-minus.png" /></p>
<p>Correttamente, il nostro programma stampa questo output:</p>
<pre><code>α=+2 makes the charge diverge</code></pre>
<h2 id="temaCpuntoC">Implementazione del punto 3</h2>
<p>È così banale da essere quasi imbarazzante! 😀 Sono appena tre righe di codice nel <code>main()</code>:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #3</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>Synchrotron synchrotron_point3<span class="op">{</span><span class="fl">2.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">};</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>simulate_for_a_fixed_time<span class="op">(</span><span class="fl">1.0</span><span class="op">,</span> synchrotron_point3<span class="op">,</span> <span class="st">&quot;point3.png&quot;</span><span class="op">);</span></span></code></pre></div>
<p>Il grafico prodotto è questo:</p>
<p><img src="images/exam3-point3.png" /></p>
<h1 id="temaD">Tema 4 (integrali, ricerca di zeri)</h1>
<p>Questo è il link per aprire il testo: <a href="https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_4.pdf" class="uri">https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_4.pdf</a></p>
<h2 id="lettura-del-testo-1">Lettura del testo</h2>
<p>La maggiore difficoltà di questo tema d’esame è il fatto che bisogna studiare una funzione complicata, perché definita tramite un integrale:</p>
<p><span class="math display">
A(x) = \int_{-d/2}^{d/2}\frac1{d}\cos\left[\frac{\sqrt{L^2 + (x - t)^2} - \sqrt{L^2 + x^2}}{\lambda}\right]\,\mathrm{d}t.
</span></p>
<p>Leggiamo come al solito il testo. Il primo punto chiede di “fare un grafico” della funzione, il che vuol dire che sarebbe sufficiente anche solo produrre una tabella con due colonne: una per <span class="math inline">x</span> e una per <span class="math inline">A(x)</span>. Fare un grafico ha però l’indubbio vantaggio di aiutarci a capire il comportamento della funzione, soprattutto alla luce di quanto può venire chiesto dopo. Sul foglio di brutta scriviamo dunque questo:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stampare valori tabulati di <span class="math inline">(x, A(x))</span> e fare un grafico</p></li>
<li><p> </p></li>
<li><p> </p></li>
</ol>
</blockquote>
<p>Il secondo punto richiede di recuperare il codice dell’<a href="carminati-esercizi-06.html#esercizio-6.2">esercizio 6.2</a>, che implementa il metodo della bisezione:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stampare valori tabulati di <span class="math inline">(x, A(x))</span> e fare un grafico</p></li>
<li><p>Usa il metodo della bisezione per trovare il primo nullo di <span class="math inline">A(x)</span></p></li>
<li><p> </p></li>
</ol>
</blockquote>
<p>Il terzo punto è una riproposizione del secondo:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stampare valori tabulati di <span class="math inline">(x, A(x))</span> e fare un grafico</p></li>
<li><p>Usa il metodo della bisezione per trovare il primo nullo di <span class="math inline">A(x)</span> (es. 6.2)</p></li>
<li><p>Usa il metodo della bisezione per trovare il primo nullo di <span class="math inline">A(x)</span> con altri due valori di <span class="math inline">\lambda</span></p></li>
</ol>
</blockquote>
<p>Da quanto scritto sul nostro foglio è chiaro che il punto 2 e il punto 3 sono molto simili, e conviene quindi implementare una funzione che permetta di risolvere sia il punto 2 che il punto 3. Questa funzione dovrà sicuramente accettare in input il parametro <span class="math inline">\lambda</span>, quindi il suo prototipo sarà</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> find_first_null<span class="op">(</span><span class="dt">double</span> lambda<span class="op">);</span></span></code></pre></div>
<p>Infine, l’ultima riga del testo fornisce un dettaglio fondamentale: bisognerà usare il metodo dei trapezi a precisione fissata, implementato nell’<a href="carminati-esercizi-07.html#esercizio-7.2">esercizio 7.2</a>, quindi aggiungiamo questa informazione al primo punto del nostro foglio:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Stampare valori tabulati di <span class="math inline">(x, A(x))</span> e fare un grafico (trapezi a prec. fissata, es. 7.2)</p></li>
<li><p>Usa il metodo della bisezione per trovare il primo nullo di <span class="math inline">A(x)</span> (es. 6.2)</p></li>
<li><p>Usa il metodo della bisezione per trovare il primo nullo di <span class="math inline">A(x)</span> con altri due valori di <span class="math inline">\lambda</span></p></li>
</ol>
</blockquote>
<h2 id="temaDpuntoA">Implementazione del punto 1</h2>
<p>Incominciamo col definire le costanti del problema, ossia quei parametri che restano immutati nello svolgimento dei vari punti:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> L<span class="op">{</span><span class="fl">1.0</span><span class="op">};</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> d<span class="op">{</span><span class="fl">100e-6</span><span class="op">};</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> target_prec<span class="op">{</span><span class="fl">1e-4</span><span class="op">};</span></span></code></pre></div>
<p>Come accennato sopra, la funzione <span class="math inline">A(x)</span> è complessa da implementare, e bisogna quindi andare cauti con l’implementazione. Dovremo implementare le seguenti funzioni:</p>
<ol type="1">
<li><p>La funzione integranda</p>
<p><span class="math display">
f(t) = \frac1{d}\cos\left[\frac{\sqrt{L^2 + (x - t)^2} - \sqrt{L^2 + x^2}}{\lambda}\right]
</span></p>
<p>che dipende anche dai parametri <span class="math inline">x</span> e <span class="math inline">\lambda</span>.</p></li>
<li><p>La funzione integrale <span class="math inline">A(x)</span>, che dipende anche dal parametro <span class="math inline">\lambda</span>, e che dovrà usare la funzione per calcolare l’integrale col metodo dei trapezi a precisione fissata.</p></li>
</ol>
<p>Usando l’approccio orientato agli oggetti, entrambe le funzioni dovrebbero essere implementate in classi derivate da <code>FunzioneBase</code>:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Integrand <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>perché in questo modo potremo usare la classe <code>Trapezoids</code> dell’<a href="carminati-esercizi-07.html#esercizio-7.2">esercizio 7.2</a> su <code>Integrand</code> per calcolare l’integrale (punto 1), e la classe <code>Bisezione</code> dell’<a href="carminati-esercizi-06.html#esercizio-6.2">esercizio 6.2</a> su <code>A</code> per trovare il primo nullo (punti 2 e 3).</p>
<p>Notiamo che <code>Integrand</code> dovrà essere integrata rispetto alla variabile <span class="math inline">t</span>, quindi dovremo implementarla così (assumendo che definiamo tutto <code>public</code> e quindi usiamo <code>struct</code>):</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Integrand <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> x<span class="op">{},</span> lambda<span class="op">{};</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> t<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>perché in questo modo <code>Trapezoids</code> “vede” solo il parametro <code>t</code> durante la sua esecuzione. Similmente, <code>A</code> andrà definito così:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">:</span> <span class="kw">public</span> FunzioneBase <span class="op">{</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> lambda<span class="op">{};</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> Eval<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Qui però implementerò una soluzione che usa i <a href="#functori">functori</a> e impiega una versione dell’algoritmo dei trapezoidi basata sui template:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Integrand <span class="op">{</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> x<span class="op">{},</span> lambda<span class="op">{};</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">double</span> t<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// As the integrand is quite complex, it&#39;s better to implement</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// it piece by piece. This is *not* going to affect the speed,</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// as the compiler is smart enough to optimize the output code</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> Lsq<span class="op">{</span>L <span class="op">*</span> L<span class="op">};</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> xsq<span class="op">{</span>x <span class="op">*</span> x<span class="op">};</span></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> sqrt1<span class="op">{</span>sqrt<span class="op">(</span>Lsq <span class="op">+</span> pow<span class="op">(</span>x <span class="op">-</span> t<span class="op">,</span> <span class="dv">2</span><span class="op">))};</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> sqrt2<span class="op">{</span>sqrt<span class="op">(</span>Lsq <span class="op">+</span> xsq<span class="op">)};</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cos<span class="op">((</span>sqrt1 <span class="op">-</span> sqrt2<span class="op">)</span> <span class="op">/</span> lambda<span class="op">)</span> <span class="op">/</span> d<span class="op">;</span></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> lambda<span class="op">{};</span></span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">double</span> x<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a>    Integrand integrand<span class="op">{</span>x<span class="op">,</span> lambda<span class="op">};</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `trapezoids_error` is a template function</span></span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">{</span>trapezoids_error<span class="op">(</span>integrand<span class="op">,</span> <span class="op">-</span>d <span class="op">/</span> <span class="dv">2</span><span class="op">,</span> d <span class="op">/</span> <span class="dv">2</span><span class="op">,</span> target_prec<span class="op">)};</span></span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Dobbiamo ora verificare la corretta definizione delle funzioni: come abbiamo detto, l’integranda è complicata ed è facile commettere errori! Possiamo usare il sito <a href="https://www.wolframalpha.com/">WolframAlpha</a> per calcolare il valore dell’integrale nel punto <span class="math inline">x = 5\,\text{cm}</span> con <span class="math inline">\lambda = 500\,\text{nm}</span>:</p>
<p><img src="images/exam4-wolfram-alpha-x=0.05.png" /></p>
<p>Il valore dell’integrale è quindi −0.192375. Implementiamo un test, ricordandoci però che nell’invocare il metodo <code>are_close</code> (che avevamo definito nel Tema 1) dobbiamo specificare che ci interessa una precisione 10⁻⁴ (uguale a <code>target_prec</code>):</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> test_code<span class="op">()</span> <span class="op">{</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>  A fn_A<span class="op">{</span><span class="fl">500e-9</span><span class="op">};</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">assert</span><span class="op">(</span>are_close<span class="op">(</span>fn_A<span class="op">(</span><span class="fl">0.05</span><span class="op">),</span> <span class="op">-</span><span class="fl">0.192375</span><span class="op">,</span> target_prec<span class="op">));</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>  cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Hurrah! All tests have passed!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A questo punto, l’implementazione del punto 1 è banale:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">double</span> lambda_point1<span class="op">{</span><span class="fl">500e-9</span><span class="op">};</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>A fn_A<span class="op">{</span>lambda_point1<span class="op">};</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #1</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>Gnuplot gpl<span class="op">{};</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>redirect_to_png<span class="op">(</span><span class="st">&quot;point1.png&quot;</span><span class="op">);</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x<span class="op">{-</span><span class="fl">0.10</span><span class="op">};</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>x <span class="op">&lt;=</span> <span class="fl">0.10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>  gpl<span class="op">.</span>add_point<span class="op">(</span>x<span class="op">,</span> fn_A<span class="op">(</span>x<span class="op">));</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>  x <span class="op">+=</span> <span class="fl">0.001</span><span class="op">;</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>plot<span class="op">();</span></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>gpl<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Output saved into file point1.png</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Questo è l’output:</p>
<pre><code>Hurrah! All tests have passed!
# Point 1

Output saved into file point1.png</code></pre>
<p>e questo è il file <code>point1.png</code>:</p>
<p><img src="images/exam4-point1.png" /></p>
<h2 id="temaDpuntoB">Implementazione del punto 2</h2>
<p>Per l’implementazione dei punti 2 e 3, abbiamo detto che è utile implementare una funzione che accetti il valore di <span class="math inline">\lambda</span> e restituisca il valore di <span class="math inline">x</span> in cui si è trovato il nullo. La versione dell’algoritmo di bisezione che uso nel codice è basata sui <a href="#template">template</a>, e sfrutta la classe <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> per indicare se la bisezione ha trovato una radice o ha fallito (perché ad esempio il teorema degli zeri non è valido):</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> bisect<span class="op">(</span><span class="kw">auto</span> fn<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">double</span> prec <span class="op">=</span> <span class="fl">1e-7</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> fn_a<span class="op">{</span>fn<span class="op">(</span>a<span class="op">)};</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> fn_b<span class="op">{</span>fn<span class="op">(</span>b<span class="op">)};</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>fn_a <span class="op">*</span> fn_b <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Hypotheses were not satisfied: ERROR!</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The following line means: “don&#39;t return a real value!”</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{};</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Later, when we want to return a double value `c`, we just write:</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">//      return c;</span></span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">//</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Quando si invoca <code>bisect</code>, si dichiara il tipo di ritorno <code>auto</code> e si verifica se il risultato contiene o meno un valore con il metodo <code>has_value()</code>; se il valore c’è, si usa il metodo <code>value()</code> per estrarlo. È più facile capire come funziona guardando direttamente l’implementazione di <code>find_first_null()</code>:</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> find_first_null<span class="op">(</span><span class="dt">double</span> lambda<span class="op">)</span> <span class="op">{</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="dt">double</span> prec<span class="op">{</span><span class="fl">1e-6</span><span class="op">};</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>  A function<span class="op">{</span>lambda<span class="op">};</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// We write `auto` here, so that the compiler will figure</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// the correct return type (std::optional&lt;double&gt;) by itself</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> result<span class="op">{</span>bisect<span class="op">(</span>function<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">)};</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Now we have to check if `bisect` was able to find the root</span></span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(!</span>result<span class="op">.</span>has_value<span class="op">())</span> <span class="op">{</span></span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Alas, `bisect()` did a `return {}`: no root! 🙁</span></span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>    cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;ERROR! No minimum found!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>    abort<span class="op">();</span></span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">// If we reach this line, a root WAS found 😀</span></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notate che nell’invocazione di <code>bisect()</code> ho specificato che lo zero è nell’intervallo <span class="math inline">[0, 0.05]</span>; ho determinato questo intervallo guardando il grafico prodotto dal punto 1.</p>
<p>L’implementazione della soluzione per il punto 2 è a questo punto banale:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #2</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;First null for λ = </span><span class="sc">{}</span><span class="st"> nm: </span><span class="sc">{:.6f}</span><span class="st"> m&quot;</span><span class="op">,</span> lambda_point1 <span class="op">*</span> <span class="fl">1e9</span><span class="op">,</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>             find_first_null<span class="op">(</span>lambda_point1<span class="op">));</span></span></code></pre></div>
<p>e questo è l’output:</p>
<pre><code># Point #2

First null for λ = 500 nm: 0.031434 m</code></pre>
<h2 id="temaDpuntoC">Implementazione del punto 3</h2>
<p>È banalmente una riproposizione del punto 2:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point #3</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">double</span> lambda1_point3<span class="op">{</span><span class="fl">400e-9</span><span class="op">};</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">double</span> lambda2_point3<span class="op">{</span><span class="fl">450e-9</span><span class="op">};</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;First null for λ = </span><span class="sc">{}</span><span class="st"> nm: </span><span class="sc">{:.6f}</span><span class="st"> m&quot;</span><span class="op">,</span> lambda1_point3 <span class="op">*</span> <span class="fl">1e9</span><span class="op">,</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>             find_first_null<span class="op">(</span>lambda1_point3<span class="op">));</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;First null for λ = </span><span class="sc">{}</span><span class="st"> nm: </span><span class="sc">{:.6f}</span><span class="st"> m&quot;</span><span class="op">,</span> lambda2_point3 <span class="op">*</span> <span class="fl">1e9</span><span class="op">,</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>             find_first_null<span class="op">(</span>lambda2_point3<span class="op">));</span></span></code></pre></div>
<p>Questo è l’output:</p>
<pre><code># Point #3

First null for λ = 400 nm: 0.025143 m
First null for λ = 450 nm: 0.028288 m</code></pre>
<h1 id="temaE">Tema 5 (simulazione di un esperimento)</h1>
<p>Questo è il link per aprire il testo: <a href="https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_5.pdf" class="uri">https://labtnds.docs.cern.ch/ProveEsame/AppelloTNDS_5.pdf</a></p>
<h2 id="lettura-del-testo-2">Lettura del testo</h2>
<p>Si tratta di un classico esercizio di simulazione di un esperimento, e può quindi essere risolto sulla falsariga dell’<a href="carminati-esercizi-11.html#esercizio-11.0">esercizio 11.0</a>. Siccome però a differenza di quell’esercizio, il tema d’esame è suddiviso in quattro punti, leggiamolo comunque per capire se sia bene implementare funzioni che possano essere utilizzate più volte nello svolgimento. Usiamo il nostro consueto foglio di brutta:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p> </p></li>
<li><p> </p></li>
<li><p> </p></li>
<li><p> </p></li>
</ol>
</blockquote>
<p>Il primo punto è proprio identico alla richiesta dell’<a href="carminati-esercizi-11.html#esercizio-11.0">esercizio 11.0</a>, quindi dovremo scrivere una classe che calcoli i parametri dell’esperimento (incluso il tempo <span class="math inline">\Delta t</span>) a partire dal valore vero di <span class="math inline">C</span>, e poi simuli la misura di <span class="math inline">C</span> per <span class="math inline">N</span> volte. Possiamo immaginare di usare <span class="math inline">N = 1000</span>, visto che il testo non richiede di usare un numero specifico.</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Simula l’esperimento per <span class="math inline">N = 1000</span> volte con una precisione del 3% sui parametri e determina l’errore percentuale su <span class="math inline">C</span> (es. 11.0)</p></li>
<li><p> </p></li>
<li><p> </p></li>
<li><p> </p></li>
</ol>
</blockquote>
<p>Il secondo punto è molto comune in questo genere di temi d’esame. Dobbiamo quindi eseguire di nuovo l’esercizio, stavolta azzerando l’errore su tutti i parametri tranne uno:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Simula l’esperimento per <span class="math inline">N = 1000</span> volte con una precisione del 3% sui parametri e determina l’errore percentuale su <span class="math inline">C</span> (es. 11.0)</p></li>
<li><p>Ripeti il punto 1 attivando l’errore solo per <span class="math inline">\Delta t</span>, <span class="math inline">R</span>, <span class="math inline">V_0</span> e <span class="math inline">V_1</span> (quattro esecuzioni)</p></li>
<li><p> </p></li>
<li><p> </p></li>
</ol>
</blockquote>
<p>Il terzo punto richiede di eseguire di nuovo la simulazione, facendo però variare l’errore sui due voltaggi <span class="math inline">V_0</span> e <span class="math inline">V_1</span>:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Simula l’esperimento per <span class="math inline">N = 1000</span> volte con una precisione del 3% sui parametri e determina l’errore percentuale su <span class="math inline">C</span> (es. 11.0)</p></li>
<li><p>Ripeti il punto 1 attivando l’errore solo per <span class="math inline">\Delta t</span>, <span class="math inline">R</span>, <span class="math inline">V_0</span> e <span class="math inline">V_1</span> (quattro esecuzioni)</p></li>
<li><p>Ripeti il punto 1 variando l’errore sui voltaggi nell’intervallo 1%–7%</p></li>
<li><p> </p></li>
</ol>
</blockquote>
<p>Infine, l’ultimo punto richiede di fare una interpolazione: avendo a disposizione i dati del punto precedente, bisogna stimare quale valore dell’errore sul voltaggio porta a un certo errore su C:</p>
<blockquote>
<p>Cose da fare:</p>
<ol type="1">
<li><p>Simula l’esperimento per <span class="math inline">N = 1000</span> volte con una precisione del 3% sui parametri e determina l’errore percentuale su <span class="math inline">C</span> (es. 11.0)</p></li>
<li><p>Ripeti il punto 1 attivando l’errore solo per <span class="math inline">\Delta t</span>, <span class="math inline">R</span>, <span class="math inline">V_0</span> e <span class="math inline">V_1</span> (quattro esecuzioni)</p></li>
<li><p>Ripeti il punto 1 variando l’errore sui voltaggi nell’intervallo 1%–7%</p></li>
<li><p>Dai risultati del punto 3, ottieni l’errore su <span class="math inline">V</span> tale che l’errore su <span class="math inline">C</span> sia 7%</p></li>
</ol>
</blockquote>
<p>Guardando questa lista dei punti, è chiaro che c’è un compito che deve essere ripetuto molte volte nello svolgimento: dati una serie di errori sui parametri <span class="math inline">\Delta t</span>, <span class="math inline">R</span>, <span class="math inline">V_0</span> e <span class="math inline">V_1</span>, bisogna stimare l’errore su <span class="math inline">C</span>. Possiamo quindi pensare di implementare una funzione di questo tipo:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> run_experiment<span class="op">(</span>RandomGen <span class="op">&amp;</span> rnd<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">double</span> delta_t_rel_error<span class="op">,</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">double</span> R_rel_error<span class="op">,</span> <span class="dt">double</span> V0_rel_error<span class="op">,</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">double</span> V1_rel_error<span class="op">)</span></span></code></pre></div>
<p>Come avevamo detto nella <a href="#temaBLetturaTesto">lettura del tema n. 2</a>, le funzioni che hanno bisogno di generare numeri pseudo-casuali dovrebbero sempre ricevere un’istanza di <code>RandomGen</code> (creata nel <code>main()</code>) come parametro, anziché creare un’istanza per sè. Qui seguiamo lo stesso principio.</p>
<p>Idealmente, il <code>double</code> restituito dalla funzione <code>run_experiment()</code> dovrebbe essere la deviazione standard dei valori di <span class="math inline">C</span> estratti tramite una simulazione Monte Carlo con <code>N</code> campioni. Tutti gli altri parametri sono errori <em>relativi</em>: quindi, un errore del 3% su <span class="math inline">\Delta t</span> sarà indicato ponendo <code>delta_t_rel_error = 0.03</code>.</p>
<p>Chiediamoci però se una funzione fatta così possa andare bene per <em>tutti</em> i punti. Se nel <code>main()</code> la usassimo così:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> run_experiment<span class="op">(</span>…<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span></code></pre></div>
<p>leggeremmo a video solo la deviazione standard di <span class="math inline">C</span>. Ma sarebbe meglio invece produrre a video anche una <em>stima</em> del valore di <span class="math inline">C</span>, per controllare che stiamo facendo tutto bene! (Se ad esempio venisse stampato un valore di <span class="math inline">C</span> nullo, oppure negativo, oppure grandissimo, vuol dire che c’è qualche errore nel codice).</p>
<p>Potremmo allora inserire un <code>cout</code> alla fine dell’esecuzione di <code>run_experiment()</code>:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>MCResults run_experiment<span class="op">(</span><span class="dt">int</span> N<span class="op">,</span> <span class="dt">double</span> delta_t_rel_error<span class="op">,</span> <span class="dt">double</span> R_rel_error<span class="op">,</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>                         <span class="dt">double</span> V0_rel_error<span class="op">,</span> <span class="dt">double</span> V1_rel_error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Fai tutti i calcoli qui</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Ora stampa il risultato</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> format<span class="op">(</span><span class="st">&quot;The best estimate for C is </span><span class="sc">{}</span><span class="st"> ± </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> mean_value<span class="op">,</span> error<span class="op">);</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> error<span class="op">;</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Questo però non sarebbe molto elegante per il punto 3, in cui ci piacerebbe stampare una tabella formattata per bene anziché il messaggio <code>The best estimate for C is…</code> su ogni riga. La cosa migliore è allora quella di fare in modo che <code>run_experiment</code> restituisca una <code>struct</code> con i risultati della simulazione:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MCResults <span class="op">{</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>MCResults run_experiment<span class="op">(</span>RandomGen <span class="op">&amp;</span>rnd<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">double</span> delta_t_rel_error<span class="op">,</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>                         <span class="dt">double</span> R_rel_error<span class="op">,</span> <span class="dt">double</span> V0_rel_error<span class="op">,</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>                         <span class="dt">double</span> V1_rel_error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Vedremo in fase di implementazione quali parametri abbia senso includere in <code>MCResults</code>.</p>
<h2 id="temaEpuntoA">Implementazione del punto 1</h2>
<p>Seguendo l’approccio dell’<a href="carminati-esercizi-11.html#esercizio-11.0">esercizio 11.0</a>, creiamo una classe con membri pubblici (<code>struct</code>) che rappresenti l’esperimento, e facciamo sì che il costruttore inizializzi tutti i parametri al valore atteso, incluso <span class="math inline">\Delta t</span> (che in un esperimento reale andrebbe misurato):</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Parameters <span class="op">{</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> C<span class="op">;</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> R<span class="op">;</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> V0<span class="op">;</span></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> V1<span class="op">;</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> <span class="dt">delta_t</span><span class="op">;</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>  Parameters<span class="op">()</span> <span class="op">:</span> C<span class="op">{</span><span class="fl">2e-6</span><span class="op">},</span> R<span class="op">{</span><span class="fl">100e3</span><span class="op">},</span> V0<span class="op">{</span><span class="dv">12</span><span class="op">},</span> V1<span class="op">{</span><span class="dv">3</span><span class="op">}</span> <span class="op">{</span> <span class="dt">delta_t</span> <span class="op">=</span> C <span class="op">*</span> R <span class="op">*</span> log<span class="op">(</span>V0 <span class="op">/</span> V1<span class="op">);</span> <span class="op">}</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> estimate_C<span class="op">()</span> <span class="op">{</span> C <span class="op">=</span> <span class="dt">delta_t</span> <span class="op">/</span> <span class="op">(</span>R <span class="op">*</span> log<span class="op">(</span>V0 <span class="op">/</span> V1<span class="op">));</span> <span class="op">}</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Ovviamente useremo il metodo <code>Parameters::estimate_C()</code> quando simuleremo l’esperimento.</p>
<p>Per implementare la funzione <code>run_experiment()</code> di cui abbiamo parlato sopra, dobbiamo stabilire quali parametri restituire all’interno della classe <code>MCResults</code>. Possiamo limitarci per il momento al numero <code>N</code> di campioni Monte Carlo, al valore medio di <span class="math inline">C</span> e al suo errore; se servirà, modificheremo la classe in modo da tenere al suo interno anche l’intero vettore di <span class="math inline">N</span> stime di <span class="math inline">C</span>, ma al momento lo tralasciamo.</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MCResults <span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> N<span class="op">;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> C_mean<span class="op">{};</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> C_stddev<span class="op">{};</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">double</span> rel_error<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> C_stddev <span class="op">/</span> C_mean<span class="op">;</span> <span class="op">}</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> print_results<span class="op">()</span> <span class="op">{</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">::</span>println<span class="op">(</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;After </span><span class="sc">{}</span><span class="st"> runs, C = </span><span class="sc">{:.4f}</span><span class="st"> ± </span><span class="sc">{:.4f}</span><span class="st"> µF, with an error of </span><span class="sc">{:.1f}</span><span class="st">%&quot;</span><span class="op">,</span> N<span class="op">,</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>        C_mean <span class="op">*</span> <span class="fl">1e6</span><span class="op">,</span> C_stddev <span class="op">*</span> <span class="fl">1e6</span><span class="op">,</span> rel_error<span class="op">()</span> <span class="op">*</span> <span class="fl">100.0</span><span class="op">);</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Ho implementato il metodo <code>MCResults::rel_error()</code> che restituisce l’errore <em>relativo</em> su <span class="math inline">C</span>, perché questo viene richiesto più volte nel testo del tema d’esame ed è quindi comodo avere un modo per calcolarlo rapidamente. Il metodo <code>MCResults::print_results()</code> ci tornerà utile per stampare i risultati di una simulazione.</p>
<p>Questa è l’implementazione di <code>run_experiment()</code>, molto semplice e banale:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>MCResults run_experiment<span class="op">(</span>RandomGen <span class="op">&amp;</span> rnd<span class="op">,</span> <span class="dt">int</span> N<span class="op">,</span> <span class="dt">double</span> delta_t_rel_error<span class="op">,</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>                         <span class="dt">double</span> R_rel_error<span class="op">,</span> <span class="dt">double</span> V0_rel_error<span class="op">,</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>                         <span class="dt">double</span> V1_rel_error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> C_samples<span class="op">;</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Initialize all the parameters to their true value</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (see how the constructor for `Parameters` is implemented)</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>  Parameters true_params<span class="op">{};</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>  RandomGen rnd<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>    Parameters cur_params<span class="op">{};</span></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>    cur_params<span class="op">.</span><span class="dt">delta_t</span> <span class="op">=</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>        rnd<span class="op">.</span>gauss<span class="op">(</span>true_params<span class="op">.</span><span class="dt">delta_t</span><span class="op">,</span> true_params<span class="op">.</span><span class="dt">delta_t</span> <span class="op">*</span> delta_t_rel_error<span class="op">);</span></span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>    cur_params<span class="op">.</span>R <span class="op">=</span> rnd<span class="op">.</span>gauss<span class="op">(</span>true_params<span class="op">.</span>R<span class="op">,</span> true_params<span class="op">.</span>R <span class="op">*</span> R_rel_error<span class="op">);</span></span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>    cur_params<span class="op">.</span>V0 <span class="op">=</span> rnd<span class="op">.</span>gauss<span class="op">(</span>true_params<span class="op">.</span>V0<span class="op">,</span> true_params<span class="op">.</span>V0 <span class="op">*</span> V0_rel_error<span class="op">);</span></span>
<span id="cb117-17"><a href="#cb117-17" aria-hidden="true" tabindex="-1"></a>    cur_params<span class="op">.</span>V1 <span class="op">=</span> rnd<span class="op">.</span>gauss<span class="op">(</span>true_params<span class="op">.</span>V1<span class="op">,</span> true_params<span class="op">.</span>V1 <span class="op">*</span> V1_rel_error<span class="op">);</span></span>
<span id="cb117-18"><a href="#cb117-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-19"><a href="#cb117-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Run the experiment and measure C</span></span>
<span id="cb117-20"><a href="#cb117-20" aria-hidden="true" tabindex="-1"></a>    cur_params<span class="op">.</span>estimate_C<span class="op">();</span></span>
<span id="cb117-21"><a href="#cb117-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-22"><a href="#cb117-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Save the value of C in the list of samples</span></span>
<span id="cb117-23"><a href="#cb117-23" aria-hidden="true" tabindex="-1"></a>    C_samples<span class="op">.</span>push_back<span class="op">(</span>cur_params<span class="op">.</span>C<span class="op">);</span></span>
<span id="cb117-24"><a href="#cb117-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb117-25"><a href="#cb117-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-26"><a href="#cb117-26" aria-hidden="true" tabindex="-1"></a>  MCResults results<span class="op">{</span>N<span class="op">,</span> mean<span class="op">(</span>C_samples<span class="op">),</span> stddev<span class="op">(</span>C_samples<span class="op">)};</span></span>
<span id="cb117-27"><a href="#cb117-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> results<span class="op">;</span></span>
<span id="cb117-28"><a href="#cb117-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>E questo è il <code>main()</code>:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>  RandomGen rnd<span class="op">{</span><span class="dv">1</span><span class="op">};</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Point 1</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>  cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 1</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>  MCResults point1<span class="op">{</span>run_experiment<span class="op">(</span>rnd<span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">)};</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>  point1<span class="op">.</span>print_results<span class="op">();</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-9"><a href="#cb118-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb118-10"><a href="#cb118-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compiliamo ed eseguiamo, ottenendo questo risultato:</p>
<pre><code># Point 1

After 1000 runs, C = 2.0052 ± 0.1055 µF, with an error of 5.3%</code></pre>
<p>Se lavorate velocemente e vi rimane tempo durante l’esame, potreste verificare questo risultato con un calcolo analitico. Dall’espressione</p>
<p><span class="math display">
C = \frac{\Delta t}{R \log\frac{V_0}{V_1}}
</span></p>
<p>la propagazione degli errori porta a</p>
<p><span class="math display">
\delta C = \sqrt{
    \left(\frac{\mathrm{d}C}{\mathrm{d}(\Delta t)}\right)^2 \delta {\Delta t}^2
    + \left(\frac{\mathrm{d}C}{\mathrm{d}R}\right)^2 \delta {R}^2
    + \left(\frac{\mathrm{d}C}{\mathrm{d}V_0}\right)^2 \delta {V}^2
    + \left(\frac{\mathrm{d}C}{\mathrm{d}V_1}\right)^2 \delta {V}^2
}.
</span></p>
<p>Esplicitando le derivate, si ottiene che</p>
<p><span class="math display">
\delta C =
\sqrt{
    \frac{\delta {\Delta t}^2}{R^2 \log^2\left(\frac{V_0}{V_1}\right)}
    + \frac{\Delta t^2 \delta R^2}{R^4 \log^2\left(\frac{V_0}{V_1}\right)}
    + \frac{\Delta t^2 \delta V^2}{R^2 V_0^2 \log^4\left(\frac{V_0}{V_1}\right)}
    + \frac{\Delta t^2 \delta V^2}{R^2 V_1^2 \log^4\left(\frac{V_0}{V_1}\right)}
}
</span></p>
<p>L’espressione sembra complessa, ma diventa più semplice se esplicitiamo gli errori <em>relativi</em> (che sono quelli che ci interessano, come dice il testo del tema d’esame!) come <span class="math inline">\delta R / R</span>, <span class="math inline">\delta \Delta t / (\Delta t)</span>, etc., e raccogliamo tutti i fattori comuni all’interno della radice quadrata:</p>
<p><span class="math display">
\delta C =
\sqrt{
\left(\frac{\Delta t}{R \log\frac{V_0}{V_1}}\right)^2 \cdot \left[
    \left(\frac{\delta \Delta t}{\Delta t}\right)^2
    + \left(\frac{\delta R}{R}\right)^2
    + \frac{\left(\frac{\delta V}{V_0}\right)^2 + \left(\frac{\delta V}{V_1}\right)^2}{\log^2\left(\frac{V_0}{V_1}\right)}
\right]}.
</span></p>
<p>(Non è un caso che l’espressioni si semplifichi così tanto: essendo <span class="math inline">C</span> espresso tramite prodotti e quozienti, è scontato che l’espressione diventi più semplice in termine di errori relativi; se invece <span class="math inline">C</span> fosse stato espresso come una <em>somma</em> di termini, l’espressione più semplice sarebbe stata quella con gli errori assoluti).</p>
<p>Siccome a noi interessa l’errore <em>relativo</em> su <span class="math inline">C</span>, riscriviamo quest’espressione:</p>
<p><span class="math display">
\frac{\delta C}C =
\frac{\delta C}{\frac{\Delta t}{R \log\frac{V_0}{V_1}}} =
\sqrt{
    \left(\frac{\delta \Delta t}{\Delta t}\right)^2
    + \left(\frac{\delta R}{R}\right)^2
    + \frac{\left(\frac{\delta V}{V_0}\right)^2 + \left(\frac{\delta V}{V_1}\right)^2}{\log^2\left(\frac{V_0}{V_1}\right)}
}
</span></p>
<p>Sostituendo i valori numerici, otteniamo</p>
<p><span class="math display">
\frac{\delta C}C =
\sqrt{\left(\frac3{100}\right)^2 + \left(\frac3{100}\right)^2 + \frac{\left(\frac3{100}\right)^2 + \left(\frac3{100}\right)^2}{\log\frac{12}3}} = \frac3{100}\sqrt{2+\frac1{\log 2}} \approx 5.5\%,
</span></p>
<p>che è compatibile con la stima 5.3% prodotta dal nostro codice.</p>
<h2 id="temaEpuntoB">Implementazione del punto 2</h2>
<p>Per risolvere il punto 2 eseguiamo una serie di simulazioni in cui assumiamo di conoscere perfettamente tutti i parametri tranne uno. (Sarebbe stato possibile fare l’inverso: simulare l’esperimento assumendo di conoscere perfettamente <em>un solo parametro</em>, ma il risultato sarebbe stato meno intuitivo da comprendere).</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Point 2</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 2</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Error on Δt</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>MCResults <span class="dt">point2_delta_t</span><span class="op">{</span>run_experiment<span class="op">(</span>rnd<span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)};</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="dt">point2_delta_t</span><span class="op">.</span>print_results<span class="op">();</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Error on R</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a>MCResults point2_R<span class="op">{</span>run_experiment<span class="op">(</span>rnd<span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)};</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>point2_R<span class="op">.</span>print_results<span class="op">();</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Error on V₀</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>MCResults point2_V0<span class="op">{</span>run_experiment<span class="op">(</span>rnd<span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="dv">0</span><span class="op">)};</span></span>
<span id="cb120-15"><a href="#cb120-15" aria-hidden="true" tabindex="-1"></a>point2_V0<span class="op">.</span>print_results<span class="op">();</span></span>
<span id="cb120-16"><a href="#cb120-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-17"><a href="#cb120-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Error on V₁</span></span>
<span id="cb120-18"><a href="#cb120-18" aria-hidden="true" tabindex="-1"></a>MCResults point2_V1<span class="op">{</span>run_experiment<span class="op">(</span>rnd<span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">)};</span></span>
<span id="cb120-19"><a href="#cb120-19" aria-hidden="true" tabindex="-1"></a>point2_V1<span class="op">.</span>print_results<span class="op">();</span></span></code></pre></div>
<p>Se compiliamo il programma e lo eseguiamo, otteniamo per il punto 2 questo output:</p>
<pre><code>After 1000 runs, C = 1.9991 ± 0.0591 µF, with an error of 3.0%
After 1000 runs, C = 2.0038 ± 0.0611 µF, with an error of 3.0%
After 1000 runs, C = 2.0029 ± 0.0447 µF, with an error of 2.2%
After 1000 runs, C = 1.9994 ± 0.0435 µF, with an error of 2.2%</code></pre>
<p>Quindi ci sono <em>due</em> misure il cui errore domina sulla stima di <span class="math inline">C</span>: la resistenza <span class="math inline">R</span> e il tempo <span class="math inline">\Delta t</span>, mentre i voltaggi contano un po’ di meno. (Se stessimo approntando un esperimento reale, questo significa che dovremmo investire un po’ più soldi per comprare un cronometro efficiente e misurare bene la resistenza <span class="math inline">R</span>, anziché perdere troppo tempo a misurare <span class="math inline">V_0</span> e <span class="math inline">V_1</span> col nostro voltmetro!).</p>
<p>Possiamo verificare che se sommiamo in quadratura i quattro errori ottenuti (assumendo quindi che siano scorrelati) otteniamo l’errore su <span class="math inline">C</span> che avevamo stimato al punto 1: un’ulteriore conferma di aver fatto i conti giusti!</p>
<p><span class="math display">
\frac{\delta C}C \approx \sqrt{(3\%)^2 + (3\%)^2 + (2.2\%)^2 + (2.2\%)^2} \approx 5.3\%.
</span></p>
<h2 id="temaEpuntoC">Implementazione del punto 3</h2>
<p>Per risolvere il punto 3 del tema d’esame non dobbiamo fare altro che costruire un ciclo per iterare sui valori dell’errore relativo per il voltaggio; dal momento che la variabile iteratrice è un <code>double</code>, usiamo un ciclo <code>while</code> anziché un <code>for</code> (il C++ permette di usare anche <code>double</code> nei <code>for</code>, ma molti compilatori producono <em>warning</em> perché in questi casi è facile introdurre bug causati da piccoli errori di arrotondamento):</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 3</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>MCResults<span class="op">&gt;</span> point3_results<span class="op">{};</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> V_rel_error <span class="op">=</span> <span class="fl">0.02</span><span class="op">;</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>Gnuplot plt<span class="op">{};</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>redirect_to_png<span class="op">(</span><span class="st">&quot;point3.png&quot;</span><span class="op">);</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="co">// These vectors will hold the numbers used to</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a><span class="co">// create the plot</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> V_rel_error_list<span class="op">{};</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> C_rel_error_list<span class="op">{};</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{:&gt;8s}\t{:&gt;8s}\t{:&gt;8s}\t{:&gt;8s}</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;σ_V[%]&quot;</span><span class="op">,</span> <span class="st">&quot;C [µF]&quot;</span><span class="op">,</span> <span class="st">&quot;σ_C [µF]&quot;</span><span class="op">,</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a>             <span class="st">&quot;σ_C [%]&quot;</span><span class="op">);</span></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>V_rel_error <span class="op">&lt;</span> <span class="fl">0.08</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>  MCResults cur_results<span class="op">{</span></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a>      run_experiment<span class="op">(</span>rnd<span class="op">,</span> <span class="dv">1000</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> <span class="fl">0.03</span><span class="op">,</span> V_rel_error<span class="op">,</span> V_rel_error<span class="op">)};</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{:8.0f}\t{:8.4f}\t{:8.4f}\t{:8.1f}</span><span class="st">&quot;</span><span class="op">,</span> V_rel_error <span class="op">*</span> <span class="dv">100</span><span class="op">,</span></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a>               cur_results<span class="op">.</span>C_mean <span class="op">*</span> <span class="fl">1e6</span><span class="op">,</span> cur_results<span class="op">.</span>C_stddev <span class="op">*</span> <span class="fl">1e6</span><span class="op">,</span></span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a>               cur_results<span class="op">.</span>rel_error<span class="op">()</span> <span class="op">*</span> <span class="fl">100.0</span><span class="op">);</span></span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a>  V_rel_error_list<span class="op">.</span>push_back<span class="op">(</span>V_rel_error <span class="op">*</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a>  C_rel_error_list<span class="op">.</span>push_back<span class="op">(</span>cur_results<span class="op">.</span>rel_error<span class="op">()</span> <span class="op">*</span> <span class="dv">100</span><span class="op">);</span></span>
<span id="cb122-25"><a href="#cb122-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-26"><a href="#cb122-26" aria-hidden="true" tabindex="-1"></a>  V_rel_error <span class="op">+=</span> <span class="fl">0.01</span><span class="op">;</span></span>
<span id="cb122-27"><a href="#cb122-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb122-28"><a href="#cb122-28" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Errore su V [%]&quot;</span><span class="op">);</span></span>
<span id="cb122-29"><a href="#cb122-29" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>set_xlabel<span class="op">(</span><span class="st">&quot;Errore su C [%]&quot;</span><span class="op">);</span></span>
<span id="cb122-30"><a href="#cb122-30" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>plot<span class="op">(</span>V_rel_error_list<span class="op">,</span> C_rel_error_list<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">,</span></span>
<span id="cb122-31"><a href="#cb122-31" aria-hidden="true" tabindex="-1"></a>         Gnuplot<span class="op">::</span>LineStyle<span class="op">::</span>LINESPOINTS<span class="op">);</span></span>
<span id="cb122-32"><a href="#cb122-32" aria-hidden="true" tabindex="-1"></a>plt<span class="op">.</span>show<span class="op">();</span></span>
<span id="cb122-33"><a href="#cb122-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-34"><a href="#cb122-34" aria-hidden="true" tabindex="-1"></a>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;Plot saved into file &#39;point3.png&#39;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Questo è l’output del programma:</p>
<pre><code># Point 3

  σ_V[%]     C [µF] σ_C [µF]    σ_C [%]
       2     2.0019  0.0947     4.7
       3     2.0006  0.1015     5.1
       4     2.0099  0.1190     5.9
       5     2.0120  0.1352     6.7
       6     2.0120  0.1502     7.5
       7     2.0110  0.1694     8.4
Plot saved into file &#39;point3.png&#39;</code></pre>
<p>E questo è il grafico prodotto; come potevamo aspettarci, all’aumentare dell’errore sul voltaggio aumenta anche l’errore sul valore di <span class="math inline">C</span>.</p>
<p><img src="images/exam5-point3.png" /></p>
<h2 id="temaEpuntoD">Implementazione del punto 4</h2>
<p>Dal momento che al punto precedente abbiamo salvato i valori del grafico, si tratta qui semplicemente di fare una interpolazione lineare; per semplicità limitiamoci ai due punti che sono a ridosso dell’errore desiderato (7%). Dobbiamo innanzitutto trovare l’indice dell’elemento appena inferiore al 7% e quello successivo, e possiamo farlo assumendo che, come mostrato dal nostro grafico prodotto al punto 3, gli errori siano crescenti:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;# Point 4</span><span class="sc">\n\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">double</span> target_C_rel_error<span class="op">{</span><span class="fl">7.0</span><span class="op">};</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> idx0<span class="op">,</span> idx1<span class="op">;</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">{};</span> i <span class="op">&lt;</span> ssize<span class="op">(</span>V_rel_error_list<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>C_rel_error_list<span class="op">.</span>at<span class="op">(</span>i<span class="op">)</span> <span class="op">&gt;=</span> target_C_rel_error<span class="op">)</span> <span class="op">{</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We have got an error larger than 7%: no need to</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// keep iterating over the list</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>    idx0 <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    idx1 <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Ora occorre scrivere il codice di interpolazione. Assegnamo i valori delle coordinate dei due punti <span class="math inline">(\delta V, \delta C)</span> su cui interpoleremo a delle variabili con nomi sensati, e stampiamoli a video per essere sicuri di aver fatto le cose per bene:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="co">// We interpolate the two values that are closest to the target error (7%)</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> errVA<span class="op">{</span>V_rel_error_list<span class="op">.</span>at<span class="op">(</span>idx0<span class="op">)};</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> errVB<span class="op">{</span>V_rel_error_list<span class="op">.</span>at<span class="op">(</span>idx1<span class="op">)};</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> errCA<span class="op">{</span>C_rel_error_list<span class="op">.</span>at<span class="op">(</span>idx0<span class="op">)};</span></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> errCB<span class="op">{</span>C_rel_error_list<span class="op">.</span>at<span class="op">(</span>idx1<span class="op">)};</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;We&#39;re going to interpolate between point (</span><span class="sc">{:.2f}</span><span class="st">, </span><span class="sc">{:.2f}</span><span class="st">) (row #</span><span class="sc">{}</span><span class="st">) &quot;</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;and point (</span><span class="sc">{:.2f}</span><span class="st">, </span><span class="sc">{:.2f}</span><span class="st">) (row #</span><span class="sc">{}</span><span class="st">)&quot;</span><span class="op">,</span></span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>    errVA<span class="op">,</span> errCA<span class="op">,</span> idx0 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> errVB<span class="op">,</span> errCB<span class="op">,</span> idx1 <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>Se eseguiamo il codice, questo è il risultato:</p>
<pre><code># Point 4

We&#39;re going to interpolate between point (5.00, 6.72) (row #4) and point (6.00, 7.46) (row #5)</code></pre>
<p>che è corretto: riprendendo la tabella e il grafico prodotti al punto 3, è evidente l’errore su <span class="math inline">V</span> che porta a un errore del 7% su <span class="math inline">C</span> deve essere compreso tra il 5% e il 6%.</p>
<p>Ora possiamo scrivere un codice che interpoli linearmente tra i due punti <span class="math inline">(\delta V_A, \delta C_A)</span> e <span class="math inline">(\delta V_B, \delta C_B)</span>. Dalla formula della retta <span class="math inline">\delta V = m \delta C + q</span> passante per i due punti</p>
<p><span class="math display">
\frac{\delta V - \delta V_A}{\delta V_A - \delta V_B} = \frac{\delta C - \delta C_A}{\delta C_A - \delta C_B}
</span></p>
<p>se poniamo <span class="math inline">\delta C_\text{target} = 7\%</span> otteniamo</p>
<p><span class="math display">
\delta V = \delta V_A + (\delta V_B - \delta V_A) \frac{\delta C_\text{target} - \delta C_A}{\delta C_B - \delta C_A},
</span></p>
<p>da cui deriva il codice</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> target_V_rel_error<span class="op">{</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    errVA <span class="op">+</span> <span class="op">(</span>errVB <span class="op">-</span> errVA<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>target_C_rel_error <span class="op">-</span> errCA<span class="op">)</span> <span class="op">/</span> <span class="op">(</span>errCB <span class="op">-</span> errCA<span class="op">)};</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>fmt<span class="op">::</span>println<span class="op">(</span><span class="st">&quot;We get </span><span class="sc">{:.2f}% e</span><span class="st">rror on C if the error on V is </span><span class="sc">{:.2f}</span><span class="st">%&quot;</span><span class="op">,</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>             target_C_rel_error<span class="op">,</span> target_V_rel_error<span class="op">);</span></span></code></pre></div>
<p>che produce come output</p>
<pre><code>We get 7.00% error on C if the error on V0/V1 is 5.38%</code></pre>
<p>in linea con quanto ci aspettavamo, ossia un valore compreso tra 5% e 6%.</p>
</main>

<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
</body>
</html>
